
> payment-analyzer-next@0.1.0 lint /mnt/c/taly/Analyser/payment-analyzer-next
> eslint . --format json

[{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/clear-supabase.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/next.config.analyze.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":60,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/next.config.production.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/postcss.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/public/cleanup-storage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/scripts/run-maintenance.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":58,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":13,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":13,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":15,"column":1,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":15,"endColumn":18,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/scripts/run-migrations.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":9,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":9,"endColumn":58,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":13,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":13,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":15,"column":1,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":15,"endColumn":18,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'runMigrations' is defined but never used.","line":18,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(auth)/callback/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(auth)/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(auth)/login/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(auth)/reset-password/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(auth)/signup/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/analysis/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/analysis/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/dashboard/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/history/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/reports/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/settings/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/(dashboard)/test/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/analysis/[id]/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/analysis/[id]/update/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/analysis/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/analysis/upload/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/export/[id]/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/export/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/migration/route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_version' is defined but never used.","line":552,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":552,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { createClient as createServerClient } from '@/lib/supabase/server';\nimport { analysisService } from '@/lib/services/analysis-service';\nimport { generateUUID } from '@/lib/utils';\nimport { z } from 'zod';\n\n// Schema for migration data validation\nconst MigrationDataSchema = z.object({\n  version: z.string(), // e.g., \"v8\", \"v9\"\n  data: z.array(z.object({\n    // Legacy analysis structure\n    id: z.string().optional(),\n    period: z.object({\n      start: z.string(),\n      end: z.string(),\n    }),\n    entries: z.array(z.object({\n      date: z.string(),\n      consignments: z.number().min(0),\n      paid: z.number().min(0),\n      bonuses: z.object({\n        unloading: z.boolean().optional(),\n        attendance: z.boolean().optional(),\n        early: z.boolean().optional(),\n      }).optional(),\n      pickups: z.number().min(0).optional(),\n    })),\n    paymentRules: z.object({\n      weekdayRate: z.number().min(0),\n      saturdayRate: z.number().min(0),\n      unloadingBonus: z.number().min(0),\n      attendanceBonus: z.number().min(0),\n      earlyBonus: z.number().min(0),\n    }).optional(),\n    metadata: z.object({\n      description: z.string().optional(),\n      notes: z.string().optional(),\n      originalId: z.string().optional(),\n      importDate: z.string().optional(),\n    }).optional(),\n  })),\n});\n\nconst ValidateRequestSchema = z.object({\n  version: z.string(),\n  sampleData: z.unknown(), // Raw data for validation\n});\n\n// Type definitions based on Zod schemas\ntype LegacyAnalysisData = z.infer<typeof MigrationDataSchema>['data'][0];\n\n// Migration progress tracking (in production, use Redis)\ninterface MigrationProgress {\n  migrationId: string;\n  stage: 'starting' | 'validating' | 'processing' | 'importing' | 'verifying' | 'completed' | 'error';\n  progress: number;\n  message: string;\n  currentItem?: number;\n  totalItems?: number;\n  processedRecords?: number;\n  totalRecords?: number;\n  errors?: { index: number; error: string | undefined; originalId: string | undefined }[];\n  processed?: number;\n  userId?: string;\n  error?: string;\n  total?: number;\n  version?: string;\n  success?: string[];\n  completedAt?: string;\n  warnings?: string[];\n  result?: {\n    successCount: number;\n    errorCount: number;\n    analysisIds: string[];\n  } | null;\n}\n\nconst migrationProgress = new Map<string, MigrationProgress>();\n\n/**\n * Update migration progress\n */\nasync function updateMigrationProgress(\n  migrationId: string, \n  processed: number, \n  total: number\n): Promise<void> {\n  const currentProgress = migrationProgress.get(migrationId);\n  if (currentProgress) {\n    migrationProgress.set(migrationId, {\n      ...currentProgress,\n      migrationId,\n      stage: 'processing',\n      progress: Math.round((processed / total) * 100),\n      message: `Processing analysis ${processed + 1} of ${total}`,\n      processed,\n    });\n  }\n}\n\n/**\n * Process a single legacy analysis\n */\nasync function processSingleAnalysis(\n  legacyAnalysis: LegacyAnalysisData,\n  version: string,\n  userId: string,\n  migrationId: string,\n  index: number\n): Promise<{ success?: string; error?: { index: number; error: string; originalId: string } }> {\n  try {\n    const convertedAnalysis = convertLegacyAnalysis(legacyAnalysis, version);\n\n    const result = await analysisService.createAnalysis({\n      userId,\n      manualEntries: convertedAnalysis.manualEntries,\n      paymentRules: convertedAnalysis.paymentRules as Partial<{\n        weekdayRate: number;\n        saturdayRate: number;\n        unloadingBonus: number;\n        attendanceBonus: number;\n        earlyBonus: number;\n      }>,\n      metadata: {\n        ...convertedAnalysis.metadata,\n        description: `Migrated from ${version}`,\n        notes: `Migration ID: ${migrationId}\\\\nOriginal data preserved`,\n      },\n    });\n\n    if (result.success) {\n      return { success: result.analysisId };\n    } else {\n      return {\n        error: {\n          index,\n          error: result.error || 'Unknown error',\n          originalId: legacyAnalysis.id || 'unknown',\n        }\n      };\n    }\n  } catch (error) {\n    return {\n      error: {\n        index,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        originalId: legacyAnalysis.id || 'unknown',\n      }\n    };\n  }\n}\n\n/**\n * Process all migration data\n */\nasync function processMigrationData(\n  migrationData: LegacyAnalysisData[],\n  migrationId: string,\n  version: string,\n  userId: string\n): Promise<{\n  processedCount: number;\n  errors: { index: number; error: string; originalId: string }[];\n  success: string[];\n}> {\n  let processed = 0;\n  const errors: { index: number; error: string; originalId: string }[] = [];\n  const success: string[] = [];\n\n  for (const legacyAnalysis of migrationData) {\n    await updateMigrationProgress(migrationId, processed, migrationData.length);\n\n    const result = await processSingleAnalysis(\n      legacyAnalysis,\n      version,\n      userId,\n      migrationId,\n      processed\n    );\n\n    if (result.success) {\n      success.push(result.success);\n    } else if (result.error) {\n      errors.push(result.error);\n    }\n\n    processed++;\n  }\n\n  return { processedCount: processed, errors, success };\n}\n\n/**\n * Set migration as completed\n */\nasync function setMigrationCompleted(\n  migrationId: string,\n  success: string[],\n  errors: { index: number; error: string; originalId: string }[],\n  processed: number\n): Promise<void> {\n  const currentProgress = migrationProgress.get(migrationId);\n  if (currentProgress) {\n    migrationProgress.set(migrationId, {\n      ...currentProgress,\n      migrationId,\n      stage: 'completed',\n      progress: 100,\n      message: `Migration completed. ${success.length} successful, ${errors.length} failed.`,\n      processed,\n      errors,\n      success,\n      completedAt: new Date().toISOString(),\n      result: {\n        successCount: success.length,\n        errorCount: errors.length,\n        analysisIds: success,\n      },\n    });\n  }\n}\n\n/**\n * Set migration as error\n */\nasync function setMigrationError(migrationId: string, error: unknown): Promise<void> {\n  const currentProgress = migrationProgress.get(migrationId);\n  if (currentProgress) {\n    migrationProgress.set(migrationId, {\n      ...currentProgress,\n      migrationId,\n      stage: 'error',\n      progress: 0,\n      message: 'Migration failed',\n      error: error instanceof Error ? error.message : 'Unknown error',\n      completedAt: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Schedule migration cleanup\n */\nfunction scheduleMigrationCleanup(migrationId: string): void {\n  setTimeout(() => {\n    migrationProgress.delete(migrationId);\n  }, 30 * 60 * 1000);\n}\n\n/**\n * POST /api/migration/import - Import legacy data\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Get authenticated user\n    const supabase = await createServerClient();\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n    \n    if (authError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Parse and validate request body\n    const body = await request.json();\n    const validationResult = MigrationDataSchema.safeParse(body);\n    \n    if (!validationResult.success) {\n      return NextResponse.json({\n        error: 'Invalid migration data format',\n        details: validationResult.error.issues\n      }, { status: 400 });\n    }\n\n    const { version, data: migrationData } = validationResult.data;\n\n    // Generate migration ID for progress tracking\n    const migrationId = generateUUID();\n\n    // Initialize progress tracking\n    migrationProgress.set(migrationId, {\n      stage: 'starting',\n      progress: 0,\n      message: 'Starting migration...',\n      total: migrationData.length,\n      processed: 0,\n      migrationId,\n      version,\n      userId: user.id,\n      errors: [],\n      success: [],\n    });\n\n    // Start migration in background\n    const processMigration = async () => {\n      try {\n        const { processedCount, errors, success } = await processMigrationData(\n          migrationData, \n          migrationId, \n          version, \n          user.id\n        );\n\n        await setMigrationCompleted(migrationId, success, errors, processedCount);\n        scheduleMigrationCleanup(migrationId);\n\n      } catch (error) {\n        await setMigrationError(migrationId, error);\n      }\n    };\n\n    // Start processing\n    processMigration();\n\n    return NextResponse.json({\n      success: true,\n      migrationId,\n      message: 'Migration started. Use the migrationId to check progress.',\n      total: migrationData.length,\n    }, { status: 202 });\n\n  } catch (error) {\n    console.error('POST /api/migration/import error:', error);\n    return NextResponse.json({ \n      error: 'Internal server error' \n    }, { status: 500 });\n  }\n}\n\n/**\n * POST /api/migration/validate - Validate migration data before import\n */\nexport async function PATCH(request: NextRequest) {\n  try {\n    // Get authenticated user\n    const supabase = await createServerClient();\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n    \n    if (authError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Parse request body\n    const body = await request.json();\n    const validationResult = ValidateRequestSchema.safeParse(body);\n    \n    if (!validationResult.success) {\n      return NextResponse.json({\n        error: 'Invalid validation request',\n        details: validationResult.error.issues\n      }, { status: 400 });\n    }\n\n    const { version, sampleData } = validationResult.data;\n\n    // Validate sample data\n    const validation = validateLegacyData(sampleData, version);\n\n    return NextResponse.json({\n      success: true,\n      validation,\n    });\n\n  } catch (error) {\n    console.error('PATCH /api/migration/validate error:', error);\n    return NextResponse.json({ \n      error: 'Internal server error' \n    }, { status: 500 });\n  }\n}\n\n/**\n * GET /api/migration/status?migrationId=... - Get migration progress\n */\nexport async function GET(request: NextRequest) {\n  try {\n    // Get authenticated user\n    const supabase = await createServerClient();\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n    \n    if (authError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const migrationId = searchParams.get('migrationId');\n\n    if (!migrationId) {\n      return NextResponse.json({ \n        error: 'migrationId is required' \n      }, { status: 400 });\n    }\n\n    const progress = migrationProgress.get(migrationId);\n\n    if (!progress) {\n      return NextResponse.json({ \n        error: 'Migration not found or expired' \n      }, { status: 404 });\n    }\n\n    // Verify ownership\n    if (progress.userId !== user.id) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n    }\n\n    return NextResponse.json({\n      success: true,\n      data: progress,\n    });\n\n  } catch (error) {\n    console.error('GET /api/migration/status error:', error);\n    return NextResponse.json({ \n      error: 'Internal server error' \n    }, { status: 500 });\n  }\n}\n\n/**\n * Convert legacy analysis data to new format\n */\nfunction convertLegacyAnalysis(legacyAnalysis: LegacyAnalysisData, version: string) {\n  const manualEntries = legacyAnalysis.entries.map((entry) => ({\n    date: entry.date,\n    consignments: entry.consignments,\n    paid: entry.paid,\n    hasUnloadingBonus: entry.bonuses?.unloading || false,\n    hasAttendanceBonus: entry.bonuses?.attendance || false,\n    hasEarlyBonus: entry.bonuses?.early || false,\n    pickups: entry.pickups || 0,\n  }));\n\n  return {\n    manualEntries,\n    paymentRules: legacyAnalysis.paymentRules,\n    metadata: {\n      description: legacyAnalysis.metadata?.description || `Migrated from ${version}`,\n      notes: legacyAnalysis.metadata?.notes,\n      originalId: legacyAnalysis.id,\n      migrationVersion: version,\n      importDate: new Date().toISOString(),\n    },\n  };\n}\n\n/**\n * Validate a single record's basic structure\n */\nfunction validateRecordStructure(record: unknown, index: number): string[] {\n  const issues: string[] = [];\n\n  if (typeof record !== 'object' || record === null) {\n    issues.push(`Record ${index + 1}: Invalid record structure`);\n    return issues;\n  }\n\n  const typedRecord = record as Record<string, unknown>;\n\n  if (!typedRecord.period || typeof typedRecord.period !== 'object' ||\n      !(typedRecord.period as Record<string, unknown>)?.start ||\n      !(typedRecord.period as Record<string, unknown>)?.end) {\n    issues.push(`Record ${index + 1}: Missing period information`);\n  }\n\n  if (!Array.isArray(typedRecord.entries) || typedRecord.entries.length === 0) {\n    issues.push(`Record ${index + 1}: Missing or empty entries array`);\n  }\n\n  return issues;\n}\n\n/**\n * Validate a single entry within a record\n */\nfunction validateEntry(entry: unknown, recordIndex: number, entryIndex: number): string[] {\n  const issues: string[] = [];\n\n  if (typeof entry !== 'object' || entry === null) {\n    issues.push(`Record ${recordIndex + 1}, Entry ${entryIndex + 1}: Invalid entry structure`);\n    return issues;\n  }\n\n  const typedEntry = entry as Record<string, unknown>;\n\n  if (!typedEntry.date) {\n    issues.push(`Record ${recordIndex + 1}, Entry ${entryIndex + 1}: Missing date`);\n  }\n\n  if (typeof typedEntry.consignments !== 'number' || typedEntry.consignments < 0) {\n    issues.push(`Record ${recordIndex + 1}, Entry ${entryIndex + 1}: Invalid consignments value`);\n  }\n\n  if (typeof typedEntry.paid !== 'number' || typedEntry.paid < 0) {\n    issues.push(`Record ${recordIndex + 1}, Entry ${entryIndex + 1}: Invalid paid amount`);\n  }\n\n  return issues;\n}\n\n/**\n * Validate all entries in a record\n */\nfunction validateRecordEntries(record: unknown, recordIndex: number): { issues: string[]; isValid: boolean } {\n  const issues: string[] = [];\n  let isValid = true;\n\n  if (typeof record !== 'object' || record === null) {\n    issues.push(`Record ${recordIndex + 1}: Invalid record structure`);\n    return { issues, isValid: false };\n  }\n\n  const typedRecord = record as Record<string, unknown>;\n\n  if (!Array.isArray(typedRecord.entries)) {\n    issues.push(`Record ${recordIndex + 1}: Invalid entries array`);\n    return { issues, isValid: false };\n  }\n\n  for (let j = 0; j < typedRecord.entries.length; j++) {\n    const entryIssues = validateEntry(typedRecord.entries[j], recordIndex, j);\n    if (entryIssues.length > 0) {\n      issues.push(...entryIssues);\n      isValid = false;\n    }\n  }\n\n  return { issues, isValid };\n}\n\n/**\n * Check for warnings in a record\n */\nfunction checkRecordWarnings(record: unknown, recordIndex: number): string[] {\n  const warnings: string[] = [];\n\n  if (typeof record !== 'object' || record === null) {\n    return warnings; // Already handled in validation\n  }\n\n  const typedRecord = record as Record<string, unknown>;\n\n  if (!typedRecord.paymentRules) {\n    warnings.push(`Record ${recordIndex + 1}: No payment rules specified, will use defaults`);\n  }\n\n  return warnings;\n}\n\n/**\n * Validate legacy data structure\n */\nfunction validateLegacyData(data: unknown, _version: string) {\n  const issues: string[] = [];\n  const warnings: string[] = [];\n  let validRecords = 0;\n  let totalRecords = 0;\n\n  try {\n    if (!Array.isArray(data)) {\n      issues.push('Data must be an array of analyses');\n      return { valid: false, issues, warnings, validRecords, totalRecords };\n    }\n\n    totalRecords = data.length;\n\n    for (let i = 0; i < data.length; i++) {\n      const record = data[i];\n      \n      // Validate basic record structure\n      const structureIssues = validateRecordStructure(record, i);\n      if (structureIssues.length > 0) {\n        issues.push(...structureIssues);\n        continue;\n      }\n\n      // Validate entries\n      const { issues: entryIssues, isValid } = validateRecordEntries(record, i);\n      issues.push(...entryIssues);\n\n      if (isValid) {\n        validRecords++;\n      }\n\n      // Check for warnings\n      const recordWarnings = checkRecordWarnings(record, i);\n      warnings.push(...recordWarnings);\n    }\n\n  } catch (error) {\n    issues.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  return {\n    valid: issues.length === 0,\n    issues,\n    warnings,\n    validRecords,\n    totalRecords,\n    canProceed: validRecords > 0,\n    summary: `${validRecords}/${totalRecords} records are valid for migration`,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/api/preferences/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/auth/callback/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/not-found.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/page.auth.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/privacy/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/terms/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/app/test-analysis/page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'router' is assigned a value but never used.","line":11,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test Analysis Page - No Authentication Required\n */\n\n'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\n\nexport default function TestAnalysisPage() {\n  const router = useRouter();\n  const [step, setStep] = useState(1);\n\n  const handleViewDetailedReport = () => {\n    console.log('📊 TEST: View Detailed Report clicked');\n    alert('View Detailed Report button works! Console has logs.');\n    // In real app, would navigate to reports\n    // router.push('/reports');\n  };\n\n  const handleStartNewAnalysis = () => {\n    console.log('🔄 TEST: Start New Analysis clicked');\n    alert('Start New Analysis button works! Resetting to step 1.');\n    setStep(1);\n  };\n\n  const mockAnalysisData = {\n    totals: {\n      totalConsignments: 57,\n      expectedTotal: 150.00,\n      paidTotal: 145.00,\n      workingDays: 5,\n      differenceTotal: -5.00\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 p-8\">\n      <div className=\"max-w-4xl mx-auto\">\n        <h1 className=\"text-3xl font-bold mb-2 text-blue-600\">Payment Analyzer Test</h1>\n        <p className=\"text-gray-600 mb-6\">Testing button functionality - Step {step}</p>\n        \n        {step === 1 && (\n          <div className=\"bg-white p-8 rounded-lg shadow-lg\">\n            <h2 className=\"text-2xl mb-4\">Step 1: Upload Data</h2>\n            <p className=\"text-gray-600 mb-6\">This simulates completing the analysis workflow.</p>\n            <button \n              onClick={() => setStep(3)}\n              className=\"bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 text-lg font-semibold\"\n            >\n              🚀 Simulate Analysis Complete\n            </button>\n          </div>\n        )}\n\n        {step === 3 && (\n          <div className=\"bg-white p-8 rounded-lg shadow-lg\">\n            <h2 className=\"text-2xl mb-6\">Step 3: Analysis Results ✅</h2>\n            \n            {/* Quick Summary */}\n            <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 mb-8\">\n              <div className=\"text-center p-6 bg-green-50 rounded-lg border border-green-200\">\n                <div className=\"text-3xl font-bold text-green-600 mb-2\">\n                  {mockAnalysisData.totals.totalConsignments}\n                </div>\n                <div className=\"text-sm font-medium text-gray-600\">Total Consignments</div>\n              </div>\n              <div className=\"text-center p-6 bg-blue-50 rounded-lg border border-blue-200\">\n                <div className=\"text-3xl font-bold text-blue-600 mb-2\">\n                  £{mockAnalysisData.totals.expectedTotal.toFixed(2)}\n                </div>\n                <div className=\"text-sm font-medium text-gray-600\">Expected Total</div>\n              </div>\n              <div className=\"text-center p-6 bg-purple-50 rounded-lg border border-purple-200\">\n                <div className=\"text-3xl font-bold text-purple-600 mb-2\">\n                  £{mockAnalysisData.totals.paidTotal.toFixed(2)}\n                </div>\n                <div className=\"text-sm font-medium text-gray-600\">Paid Total</div>\n              </div>\n            </div>\n\n            {/* Action Buttons - This is what we're testing */}\n            <div className=\"bg-gray-50 p-6 rounded-lg\">\n              <h3 className=\"text-lg font-semibold mb-4\">Test These Buttons:</h3>\n              <div className=\"flex flex-col sm:flex-row gap-4 justify-center\">\n                <button\n                  onClick={handleViewDetailedReport}\n                  className=\"bg-blue-600 text-white px-8 py-4 rounded-lg hover:bg-blue-700 text-lg font-semibold transition-colors flex items-center justify-center gap-2\"\n                >\n                  📊 View Detailed Report\n                </button>\n                <button\n                  onClick={handleStartNewAnalysis}\n                  className=\"bg-gray-600 text-white px-8 py-4 rounded-lg hover:bg-gray-700 text-lg font-semibold transition-colors flex items-center justify-center gap-2\"\n                >\n                  🔄 Start New Analysis\n                </button>\n              </div>\n              <p className=\"text-sm text-gray-500 mt-4 text-center\">\n                ✓ Click buttons and check browser console for logs<br/>\n                ✓ Both buttons should show alerts when clicked\n              </p>\n            </div>\n\n            {/* Analysis Summary */}\n            <div className=\"mt-8 bg-blue-50 p-6 rounded-lg\">\n              <h3 className=\"text-lg font-semibold mb-4 text-blue-800\">Analysis Summary</h3>\n              <div className=\"space-y-2 text-sm\">\n                <div className=\"flex justify-between\">\n                  <span>Working Days:</span>\n                  <span className=\"font-medium\">{mockAnalysisData.totals.workingDays}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Total Consignments:</span>\n                  <span className=\"font-medium\">{mockAnalysisData.totals.totalConsignments}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Expected Total:</span>\n                  <span className=\"font-medium\">£{mockAnalysisData.totals.expectedTotal.toFixed(2)}</span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Paid Total:</span>\n                  <span className=\"font-medium\">£{mockAnalysisData.totals.paidTotal.toFixed(2)}</span>\n                </div>\n                <div className=\"flex justify-between border-t pt-2\">\n                  <span>Difference:</span>\n                  <span className={`font-bold ${mockAnalysisData.totals.differenceTotal >= 0 ? 'text-green-600' : 'text-red-600'}`}>\n                    £{mockAnalysisData.totals.differenceTotal.toFixed(2)}\n                  </span>\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/add-entry-form.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'selectedDate' object construction makes the dependencies of useMemo Hook (at line 86) change on every render. To fix this, wrap the initialization of 'selectedDate' in its own useMemo() Hook.","line":66,"column":9,"nodeType":"VariableDeclarator","endLine":66,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Add Entry Form Component (Refactored)\n * Form for adding new manual entries, using react-hook-form and zod.\n */\n\n'use client';\n\nimport { useMemo } from 'react';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { motion } from 'framer-motion';\nimport { format } from 'date-fns';\nimport { Save, X, Calculator, Loader2 } from 'lucide-react';\n\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from '@/components/ui/form';\nimport { cn, formatCurrency, getDayName } from '@/lib/utils';\nimport { calculateExpectedPayment } from '@/lib/utils/payment-utils';\nimport { PaymentRules } from '@/lib/domain/entities';\nimport { createManualEntrySchema, ManualEntryFormValues } from '@/lib/domain/schemas/manual-entry-schema';\nimport type { ManualEntryData } from './manual-entry';\n\ninterface AddEntryFormProps {\n  readonly onAdd: (entry: Omit<ManualEntryData, 'id' | 'expectedAmount' | 'difference'>) => void;\n  readonly onCancel: () => void;\n  readonly existingDates: Date[];\n  readonly paymentRules?: PaymentRules;\n  readonly initialDate?: Date;\n}\n\nexport function AddEntryForm({\n  onAdd,\n  onCancel,\n  existingDates,\n  paymentRules,\n  initialDate = new Date(),\n}: AddEntryFormProps) {\n  const manualEntrySchema = useMemo(() => {\n    return createManualEntrySchema(existingDates);\n  }, [existingDates]);\n\n  const form = useForm<ManualEntryFormValues>({\n    resolver: zodResolver(manualEntrySchema),\n    defaultValues: {\n      date: format(initialDate, 'yyyy-MM-dd'),\n      consignments: 0,\n      paidAmount: 0,\n    },\n  });\n\n  const { isSubmitting } = form.formState;\n\n  const watchedValues = form.watch();\n  const selectedDate = new Date(watchedValues.date);\n  const dayOfWeek = selectedDate.getDay();\n  const dayName = getDayName(selectedDate);\n  const isSunday = dayOfWeek === 0;\n\n  const preview = useMemo(() => {\n    const consignmentCount = watchedValues.consignments || 0;\n    const paidAmountValue = watchedValues.paidAmount || 0;\n\n    const calculation = calculateExpectedPayment(selectedDate, consignmentCount, paymentRules);\n    const difference = paidAmountValue - calculation.expectedAmount;\n    \n    return {\n      rate: calculation.basePayment / (consignmentCount || 1),\n      basePayment: calculation.basePayment,\n      bonuses: calculation.bonuses,\n      totalBonuses: calculation.totalBonuses,\n      expectedAmount: calculation.expectedAmount,\n      difference,\n    };\n  }, [watchedValues, selectedDate, paymentRules]);\n\n  function onSubmit(values: ManualEntryFormValues) {\n    onAdd({\n      date: new Date(values.date),\n      consignments: values.consignments,\n      paidAmount: values.paidAmount,\n    });\n  }\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, height: 0 }}\n      animate={{ opacity: 1, height: 'auto' }}\n      exit={{ opacity: 0, height: 0 }}\n      transition={{ duration: 0.2 }}\n    >\n      <Card>\n        <CardContent className=\"space-y-4 pt-6\">\n          <div className=\"flex items-center justify-between\">\n            <h4 className=\"font-semibold text-slate-900\">Add New Entry</h4>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={onCancel}\n            >\n              <X className=\"w-4 h-4\" />\n            </Button>\n          </div>\n\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                <FormField\n                  control={form.control}\n                  name=\"date\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Date</FormLabel>\n                      <FormControl>\n                        <Input type=\"date\" {...field} />\n                      </FormControl>\n                      <FormDescription>\n                        {isSunday ? 'Warning: Sunday is typically non-working.' : ''}\n                      </FormDescription>\n                      <FormMessage />\n                      {watchedValues.date && (\n                        <div className=\"mt-2 flex items-center space-x-2\">\n                          <Badge variant=\"secondary\" size=\"sm\">\n                            {dayName}\n                          </Badge>\n                          {dayOfWeek === 6 && (\n                            <Badge variant=\"info\" size=\"sm\">\n                              Saturday Rate\n                            </Badge>\n                          )}\n                        </div>\n                      )}\n                    </FormItem>\n                  )}\n                />\n\n                <FormField\n                  control={form.control}\n                  name=\"consignments\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Consignments</FormLabel>\n                      <FormControl>\n                        <Input type=\"number\" placeholder=\"0\" {...field} />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n\n                <FormField\n                  control={form.control}\n                  name=\"paidAmount\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Paid Amount (£)</FormLabel>\n                      <FormControl>\n                        <Input type=\"number\" placeholder=\"0.00\" step=\"0.01\" {...field} />\n                      </FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )}\n                />\n              </div>\n\n              {watchedValues.date && watchedValues.consignments > 0 && (\n                <Card variant=\"flat\" className=\"bg-blue-50\">\n                  <CardContent>\n                    <div className=\"flex items-center space-x-2 mb-3\">\n                      <Calculator className=\"w-4 h-4 text-blue-600\" />\n                      <h5 className=\"font-medium text-blue-900\">Calculation Preview</h5>\n                    </div>\n                    <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n                        <div>\n                          <div className=\"text-slate-600\">Base Pay</div>\n                          <div className=\"font-semibold\">\n                            {watchedValues.consignments || 0} × £{preview.rate.toFixed(2)} = {formatCurrency(preview.basePayment)}\n                          </div>\n                        </div>\n    \n                        <div>\n                          <div className=\"text-slate-600\">Bonuses</div>\n                          <div className=\"space-y-1\">\n                            {preview.bonuses.unloading > 0 && (\n                              <div className=\"text-xs\">Unloading: {formatCurrency(preview.bonuses.unloading)}</div>\n                            )}\n                            {preview.bonuses.attendance > 0 && (\n                              <div className=\"text-xs\">Attendance: {formatCurrency(preview.bonuses.attendance)}</div>\n                            )}\n                            {preview.bonuses.early > 0 && (\n                              <div className=\"text-xs\">Early: {formatCurrency(preview.bonuses.early)}</div>\n                            )}\n                          </div>\n                          <div className=\"font-semibold\">\n                            {formatCurrency(preview.totalBonuses)}\n                          </div>\n                        </div>\n    \n                        <div>\n                          <div className=\"text-slate-600\">Expected</div>\n                          <div className=\"font-semibold text-blue-700\">\n                            {formatCurrency(preview.expectedAmount)}\n                          </div>\n                        </div>\n    \n                        <div>\n                          <div className=\"text-slate-600\">Difference</div>\n                          <div className={cn(\n                            'font-semibold',\n                            preview.difference >= 0 ? 'text-green-600' : 'text-red-600'\n                          )}>\n                            {preview.difference >= 0 ? '+' : ''}{formatCurrency(preview.difference)}\n                          </div>\n                        </div>\n                    </div>\n                  </CardContent>\n                </Card>\n              )}\n\n              <div className=\"flex justify-end space-x-2\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={onCancel}\n                  disabled={isSubmitting}\n                >\n                  Cancel\n                </Button>\n                \n                <Button\n                  type=\"submit\"\n                  disabled={isSubmitting}\n                >\n                  {isSubmitting ? (\n                    <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n                  ) : (\n                    <Save className=\"w-4 h-4 mr-2\" />\n                  )}\n                  Add Entry\n                </Button>\n              </div>\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n    </motion.div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/analysis-results-table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/analysis-summary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/entry-cards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/entry-row.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_paymentRules' is defined but never used.","line":44,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Entry Row Component\n * Individual row for displaying and editing manual entries\n */\n\n'use client';\n\nimport { useState, useEffect, ComponentType } from 'react';\nimport { \n  loadFramerMotion, \n  StaticDiv,\n  type MotionDivProps\n} from '@/lib/optimization/dynamic-motion';\nimport { format } from 'date-fns';\nimport { Edit2, Trash2, Save, X } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport { cn, formatCurrency, getDayName } from '@/lib/utils';\nimport { PaymentRules } from '@/lib/domain/entities';\nimport type { ManualEntryData } from './manual-entry';\n\ninterface EntryRowProps {\n  entry: ManualEntryData;\n  isEditing: boolean;\n  onUpdate: (updates: Partial<ManualEntryData>) => void;\n  onStartEdit: () => void;\n  onCancelEdit: () => void;\n  onSaveEdit: () => void;\n  onRemove: () => void;\n  disabled: boolean;\n  paymentRules?: PaymentRules;\n}\n\nexport function EntryRow({\n  entry,\n  isEditing,\n  onUpdate,\n  onStartEdit,\n  onCancelEdit,\n  onSaveEdit,\n  onRemove,\n  disabled,\n  paymentRules: _paymentRules,\n}: EntryRowProps) {\n  const [editValues, setEditValues] = useState({\n    date: format(entry.date, 'yyyy-MM-dd'),\n    consignments: typeof entry.consignments === 'number' ? entry.consignments.toString() : String(entry.consignments || 0),\n    paidAmount: typeof entry.paidAmount === 'number' ? entry.paidAmount.toString() : String(entry.paidAmount || 0),\n  });\n\n  // Dynamic motion loading\n  const [motionComponents, setMotionComponents] = useState<{\n    MotionDiv: ComponentType<MotionDivProps>;\n  }>({\n    MotionDiv: StaticDiv,\n  });\n\n  useEffect(() => {\n    // Load framer-motion only when component mounts\n    loadFramerMotion().then(({ motion }) => {\n      setMotionComponents({\n        MotionDiv: motion.div as ComponentType<MotionDivProps>,\n      });\n    });\n  }, []);\n\n  const dayName = getDayName(entry.date);\n  const dayOfWeek = entry.date.getDay();\n  const isSunday = dayOfWeek === 0;\n  const isSaturday = dayOfWeek === 6;\n\n  const handleSave = () => {\n    const newDate = new Date(editValues.date);\n    const newConsignments = parseInt(editValues.consignments) || 0;\n    const newPaidAmount = parseFloat(editValues.paidAmount) || 0;\n\n    onUpdate({\n      date: newDate,\n      consignments: newConsignments,\n      paidAmount: newPaidAmount,\n    });\n    \n    onSaveEdit();\n  };\n\n  const handleCancel = () => {\n    // Reset to original values\n    setEditValues({\n      date: format(entry.date, 'yyyy-MM-dd'),\n      consignments: typeof entry.consignments === 'number' ? entry.consignments.toString() : String(entry.consignments || 0),\n      paidAmount: typeof entry.paidAmount === 'number' ? entry.paidAmount.toString() : String(entry.paidAmount || 0),\n    });\n    onCancelEdit();\n  };\n\n  const getDifferenceColor = (difference: number) => {\n    if (Math.abs(difference) < 0.01) return 'text-slate-600';\n    return difference >= 0 ? 'text-green-600' : 'text-red-600';\n  };\n\n  const getDifferenceIcon = (difference: number) => {\n    if (Math.abs(difference) < 0.01) return '';\n    return difference >= 0 ? '+' : '';\n  };\n\n  const { MotionDiv } = motionComponents;\n\n  if (isEditing) {\n    return (\n      <MotionDiv\n        initial={{ backgroundColor: '#f8fafc' }}\n        animate={{ backgroundColor: '#ffffff' }}\n        className=\"px-4 py-4 space-y-4\"\n      >\n        <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\n          <div>\n            <label className=\"block text-xs font-medium text-slate-700 mb-1\">\n              Date\n            </label>\n            <Input\n              type=\"date\"\n              value={editValues.date}\n              onChange={(e) => setEditValues(prev => ({ ...prev, date: e.target.value }))}\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-xs font-medium text-slate-700 mb-1\">\n              Consignments\n            </label>\n            <Input\n              type=\"number\"\n              value={editValues.consignments}\n              onChange={(e) => setEditValues(prev => ({ ...prev, consignments: e.target.value }))}\n              min=\"0\"\n              step=\"1\"\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-xs font-medium text-slate-700 mb-1\">\n              Paid Amount (£)\n            </label>\n            <Input\n              type=\"number\"\n              value={editValues.paidAmount}\n              onChange={(e) => setEditValues(prev => ({ ...prev, paidAmount: e.target.value }))}\n              min=\"0\"\n              step=\"0.01\"\n            />\n          </div>\n\n          <div className=\"flex items-end space-x-2\">\n            <Button\n              onClick={handleSave}\n            >\n              <Save className=\"w-4 h-4\" />\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={handleCancel}\n            >\n              <X className=\"w-4 h-4\" />\n            </Button>\n          </div>\n        </div>\n      </MotionDiv>\n    );\n  }\n\n  return (\n    <MotionDiv\n      initial={{ opacity: 0, y: -10 }}\n      animate={{ opacity: 1, y: 0 }}\n      exit={{ opacity: 0, y: -10 }}\n      className=\"px-4 py-4 hover:bg-slate-50 transition-colors\"\n    >\n      <div className=\"flex items-center justify-between\">\n        {/* Date and day info */}\n        <div className=\"flex items-center space-x-3 min-w-0 flex-1\">\n          <div>\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"font-semibold text-slate-900\">\n                {format(entry.date, 'dd/MM/yyyy')}\n              </span>\n              \n              <Badge \n                variant={isSunday ? 'warning' : isSaturday ? 'info' : 'secondary'}\n                >\n                {dayName}\n              </Badge>\n            </div>\n            \n            <div className=\"text-sm text-slate-600 mt-1\">\n              {entry.consignments} consignments\n            </div>\n          </div>\n        </div>\n\n        {/* Payment info */}\n        <div className=\"flex items-center space-x-6 text-sm\">\n          <div className=\"text-right\">\n            <div className=\"text-slate-600\">Expected</div>\n            <div className=\"font-semibold\">\n              {formatCurrency(entry.expectedAmount || 0)}\n            </div>\n          </div>\n\n          <div className=\"text-right\">\n            <div className=\"text-slate-600\">Paid</div>\n            <div className=\"font-semibold\">\n              {formatCurrency(entry.paidAmount)}\n            </div>\n          </div>\n\n          <div className=\"text-right min-w-[80px]\">\n            <div className=\"text-slate-600\">Difference</div>\n            <div className={cn(\n              'font-semibold',\n              getDifferenceColor(entry.difference || 0)\n            )}>\n              {getDifferenceIcon(entry.difference || 0)}\n              {formatCurrency(Math.abs(entry.difference || 0))}\n            </div>\n          </div>\n\n          {/* Actions */}\n          <div className=\"flex items-center space-x-1\">\n            <Button\n              variant=\"ghost\"\n              onClick={onStartEdit}\n              disabled={disabled}\n            >\n              <Edit2 className=\"w-4 h-4\" />\n            </Button>\n            \n            <Button\n              variant=\"ghost\"\n              onClick={onRemove}\n              disabled={disabled}\n              className=\"text-slate-400 hover:text-red-600\"\n            >\n              <Trash2 className=\"w-4 h-4\" />\n            </Button>\n          </div>\n        </div>\n      </div>\n    </MotionDiv>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/file-update-detector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/file-update-indicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/file-upload-enhanced.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/file-upload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/file-validation-panel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/inline-report-modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/kpi-section.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/legacy-upload-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/manual-entry.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/progress-overlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/step-navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/step3-analyze-section-minimal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/step3-analyze-section-v2.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/step3-analyze-section-v3.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/step3-content-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/step3-event-handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/update-analysis-dialog.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CheckCircle' is defined but never used.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { Button } from '@/components/ui/button';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog';\nimport { FileUpload } from '@/components/analysis/file-upload';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Label } from '@/components/ui/label';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Progress } from '@/components/ui/progress';\nimport { CheckCircle, AlertCircle, Info } from 'lucide-react';\nimport { toast } from '@/hooks/use-toast';\n\ninterface UpdateAnalysisDialogProps {\n  analysisId: string;\n  isOpen: boolean;\n  onClose: () => void;\n  onSuccess?: () => void;\n}\n\ntype MergeStrategy = 'smart' | 'add' | 'replace' | 'max';\n\nexport function UpdateAnalysisDialog({\n  analysisId,\n  isOpen,\n  onClose,\n  onSuccess\n}: UpdateAnalysisDialogProps) {\n  const [files, setFiles] = useState<File[]>([]);\n  const [mergeStrategy, setMergeStrategy] = useState<MergeStrategy>('smart');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const router = useRouter();\n\n  const handleFilesSelected = (selectedFiles: File[]) => {\n    setFiles(selectedFiles);\n    setError(null);\n  };\n\n  const handleSubmit = async () => {\n    if (files.length === 0) {\n      setError('Please select at least one file to upload');\n      return;\n    }\n\n    setIsProcessing(true);\n    setProgress(0);\n    setError(null);\n\n    try {\n      // Convert files to base64\n      const fileData = await Promise.all(\n        files.map(async (file) => {\n          const arrayBuffer = await file.arrayBuffer();\n          const base64 = btoa(\n            new Uint8Array(arrayBuffer).reduce(\n              (data, byte) => data + String.fromCharCode(byte),\n              ''\n            )\n          );\n          \n          // Detect file type from name\n          const fileType = file.name.toLowerCase().includes('invoice') ? 'invoice' : 'runsheet';\n          \n          return {\n            name: file.name,\n            type: fileType,\n            content: base64\n          };\n        })\n      );\n\n      setProgress(30);\n\n      // Send update request\n      const response = await fetch(`/api/analysis/${analysisId}/update`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          files: fileData,\n          mergeStrategy\n        }),\n      });\n\n      setProgress(80);\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Failed to update analysis');\n      }\n\n      const result = await response.json();\n      setProgress(100);\n\n      toast({\n        title: 'Analysis Updated',\n        description: `Updated ${result.updatedEntries} entries and created ${result.createdEntries} new entries.`,\n      });\n\n      // Refresh the page to show updated data\n      if (onSuccess) {\n        onSuccess();\n      } else {\n        router.refresh();\n      }\n      \n      onClose();\n    } catch (err) {\n      console.error('Error updating analysis:', err);\n      setError(err instanceof Error ? err.message : 'Failed to update analysis');\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent className=\"sm:max-w-[600px]\">\n        <DialogHeader>\n          <DialogTitle>Update Analysis</DialogTitle>\n          <DialogDescription>\n            Add new files to this analysis. The system will intelligently merge the data with existing entries.\n          </DialogDescription>\n        </DialogHeader>\n\n        <div className=\"space-y-6 py-4\">\n          {/* File Upload */}\n          <div>\n            <Label className=\"text-base font-semibold mb-2 block\">Upload Files</Label>\n            <FileUpload\n              onFilesAdded={handleFilesSelected}\n              accept=\".pdf\"\n              multiple\n              maxFiles={10}\n            />\n            {files.length > 0 && (\n              <div className=\"mt-2 text-sm text-muted-foreground\">\n                {files.length} file{files.length > 1 ? 's' : ''} selected\n              </div>\n            )}\n          </div>\n\n          {/* Merge Strategy */}\n          <div>\n            <Label className=\"text-base font-semibold mb-2 block\">Payment Merge Strategy</Label>\n            <RadioGroup value={mergeStrategy} onValueChange={(value) => setMergeStrategy(value as MergeStrategy)}>\n              <div className=\"space-y-3\">\n                <div className=\"flex items-start space-x-2\">\n                  <RadioGroupItem value=\"smart\" id=\"smart\" className=\"mt-1\" />\n                  <div className=\"grid gap-1\">\n                    <Label htmlFor=\"smart\" className=\"font-medium cursor-pointer\">\n                      Smart Merge (Recommended)\n                    </Label>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Intelligently decides whether to add or replace payments based on amount differences\n                    </p>\n                  </div>\n                </div>\n                \n                <div className=\"flex items-start space-x-2\">\n                  <RadioGroupItem value=\"add\" id=\"add\" className=\"mt-1\" />\n                  <div className=\"grid gap-1\">\n                    <Label htmlFor=\"add\" className=\"font-medium cursor-pointer\">\n                      Add Payments\n                    </Label>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Add new payment amounts to existing amounts\n                    </p>\n                  </div>\n                </div>\n                \n                <div className=\"flex items-start space-x-2\">\n                  <RadioGroupItem value=\"replace\" id=\"replace\" className=\"mt-1\" />\n                  <div className=\"grid gap-1\">\n                    <Label htmlFor=\"replace\" className=\"font-medium cursor-pointer\">\n                      Replace Payments\n                    </Label>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Replace existing payment amounts with new ones\n                    </p>\n                  </div>\n                </div>\n                \n                <div className=\"flex items-start space-x-2\">\n                  <RadioGroupItem value=\"max\" id=\"max\" className=\"mt-1\" />\n                  <div className=\"grid gap-1\">\n                    <Label htmlFor=\"max\" className=\"font-medium cursor-pointer\">\n                      Use Maximum\n                    </Label>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Keep the higher of the existing or new payment amount\n                    </p>\n                  </div>\n                </div>\n              </div>\n            </RadioGroup>\n          </div>\n\n          {/* Info Alert */}\n          <Alert>\n            <Info className=\"h-4 w-4\" />\n            <AlertDescription>\n              <strong>How it works:</strong> Runsheet data will update consignment counts and expected amounts. \n              Invoice data will update payment amounts based on your selected merge strategy.\n            </AlertDescription>\n          </Alert>\n\n          {/* Error Alert */}\n          {error && (\n            <Alert variant=\"destructive\">\n              <AlertCircle className=\"h-4 w-4\" />\n              <AlertDescription>{error}</AlertDescription>\n            </Alert>\n          )}\n\n          {/* Progress */}\n          {isProcessing && (\n            <div className=\"space-y-2\">\n              <Progress value={progress} />\n              <p className=\"text-sm text-muted-foreground text-center\">\n                Processing files...\n              </p>\n            </div>\n          )}\n        </div>\n\n        <DialogFooter>\n          <Button variant=\"outline\" onClick={onClose} disabled={isProcessing}>\n            Cancel\n          </Button>\n          <Button onClick={handleSubmit} disabled={isProcessing || files.length === 0}>\n            {isProcessing ? 'Processing...' : 'Update Analysis'}\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/validation-badge-system.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/week-toggle-fix.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used.","line":18,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Emergency Week Toggle Fix\n * Simplified fallback functionality - main logic is now in step3-event-handlers.ts\n * This is kept as a manual emergency fix for debugging purposes only\n */\n\nexport function forceWeekToggleToWork(): void {\n  console.log('🔧 Emergency week toggle fix (should not be needed with MutationObserver)');\n  \n  const weekHeaders = document.querySelectorAll('.week-header');\n  console.log(`Emergency fix: Found ${weekHeaders.length} week headers`);\n  \n  if (weekHeaders.length === 0) {\n    console.log('⚠️ No week headers found for emergency fix');\n    return;\n  }\n  \n  weekHeaders.forEach((header, index) => {\n    const weekId = header.getAttribute('data-week-id');\n    if (!weekId) return;\n    \n    // Only attach if no listener is already present\n    if ((header as Element & { _step3WeekListenerAttached?: boolean })._step3WeekListenerAttached) {\n      console.log(`⏭️ Emergency fix: Header ${weekId} already has listener, skipping`);\n      return;\n    }\n    \n    console.log(`🔧 Emergency fix: Adding click handler to ${weekId}`);\n    \n    (header as HTMLElement).onclick = function(e) {\n      console.log(`🖱️ EMERGENCY CLICK: ${weekId}`);\n      e.preventDefault();\n      e.stopPropagation();\n      \n      // Use exact ID pattern from original HTML: weekId + \"-content\"\n      const content = document.getElementById(`${weekId}-content`);\n      \n      if (!content) {\n        console.error(`❌ Emergency fix: No content found for ${weekId}`);\n        return;\n      }\n      \n      // CSS class-based toggle logic to match main implementation\n      const isExpanded = content.classList.contains('expanded');\n      \n      if (isExpanded) {\n        content.classList.remove('expanded');\n        header.classList.remove('expanded');\n        console.log(`🔼 Emergency fix: Collapsed ${weekId} - removed expanded classes`);\n      } else {\n        content.classList.add('expanded');\n        header.classList.add('expanded');\n        console.log(`🔽 Emergency fix: Expanded ${weekId} - added expanded classes`);\n      }\n      \n      return false;\n    };\n    \n    (header as Element & { _step3WeekListenerAttached?: boolean })._step3WeekListenerAttached = true;\n  });\n}\n\n// Make available globally for manual debugging\nif (typeof window !== 'undefined') {\n  (window as typeof window & { forceWeekToggleToWork?: typeof forceWeekToggleToWork }).forceWeekToggleToWork = forceWeekToggleToWork;\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/weekly-breakdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/analysis/workflow-cards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/charts/chart-container.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/charts/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/charts/kpi-cards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/charts/period-selector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/charts/revenue-chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/charts/trend-indicator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getTrendText' is assigned a value but never used.","line":60,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Trend Indicator Component\n * Shows trend direction with percentage change and color coding\n */\n\n'use client';\n\nimport { TrendingUp, TrendingDown, Minus } from 'lucide-react';\nimport { Badge } from '@/components/ui';\n\ninterface TrendIndicatorProps {\n  value: number; // Percentage change\n  label?: string;\n  size?: 'sm' | 'md' | 'lg';\n  showBadge?: boolean;\n  className?: string;\n}\n\nexport function TrendIndicator({ \n  value, \n  label, \n  size = 'md', \n  showBadge = true,\n  className = '' \n}: TrendIndicatorProps) {\n  const getTrendColor = () => {\n    if (value > 0) return 'text-green-600';\n    if (value < 0) return 'text-red-600';\n    return 'text-slate-400';\n  };\n\n  const getBadgeVariant = () => {\n    if (value > 0) return 'success' as const;\n    if (value < 0) return 'error' as const;\n    return 'secondary' as const;\n  };\n\n  const getTrendIcon = () => {\n    const iconSize = {\n      sm: 'w-3 h-3',\n      md: 'w-4 h-4', \n      lg: 'w-5 h-5'\n    }[size];\n\n    if (value > 0) {\n      return <TrendingUp className={iconSize} />;\n    } else if (value < 0) {\n      return <TrendingDown className={iconSize} />;\n    } else {\n      return <Minus className={iconSize} />;\n    }\n  };\n\n  const formatValue = () => {\n    if (value === 0) return '0%';\n    const absValue = Math.abs(value);\n    return `${absValue.toFixed(1)}%`;\n  };\n\n  const getTrendText = () => {\n    if (value > 0) return 'increase';\n    if (value < 0) return 'decrease';\n    return 'no change';\n  };\n\n  if (showBadge) {\n    return (\n      <Badge \n        variant={getBadgeVariant()} \n        className={`inline-flex items-center space-x-1 ${className}`}\n      >\n        {getTrendIcon()}\n        <span className=\"text-xs\">\n          {formatValue()}\n          {label && ` ${label}`}\n        </span>\n      </Badge>\n    );\n  }\n\n  return (\n    <div className={`inline-flex items-center space-x-1 ${getTrendColor()} ${className}`}>\n      {getTrendIcon()}\n      <span className={`${size === 'sm' ? 'text-xs' : size === 'lg' ? 'text-base' : 'text-sm'} font-medium`}>\n        {formatValue()}\n      </span>\n      {label && (\n        <span className={`${size === 'sm' ? 'text-xs' : size === 'lg' ? 'text-sm' : 'text-xs'} opacity-75`}>\n          {label}\n        </span>\n      )}\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/dashboard/quick-stats-overview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/dev/config-check.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/diagnostics/env-check.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/error-boundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is assigned a value but never used.","line":67,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect } from 'react';\nimport { cleanupCorruptedStorage } from '@/lib/utils/storage-cleanup';\nimport { initializeStorageInterceptor } from '@/lib/utils/storage-interceptor';\n\nexport function ErrorHandler() {\n  useEffect(() => {\n    // Initialize storage interceptor to prevent future issues\n    initializeStorageInterceptor();\n    \n    // Clean up any corrupted storage on app start\n    cleanupCorruptedStorage();\n    \n    // Handle unhandled promise rejections\n    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n      const error = event.reason;\n      \n      // Filter out extension-related JSON parsing errors\n      if (error && \n          typeof error === 'object' && \n          error.message && \n          typeof error.message === 'string') {\n        \n        const errorMessage = error.message.toLowerCase();\n        \n        // Check if it's a JSON parsing error from browser extensions\n        if ((errorMessage.includes('not valid json') || \n             errorMessage.includes('unexpected token') ||\n             errorMessage.includes('json.parse') ||\n             errorMessage.includes('[object object]')) &&\n            (error.stack && (error.stack.includes('content.js') || \n                           error.stack.includes('_storageChangeDispatcher') ||\n                           error.stack.includes('_storageChangeDispatcherCallback')))) {\n          \n          // Prevent this error from showing in console\n          event.preventDefault();\n          return;\n        }\n      }\n      \n      // Check for specific extension-related error patterns\n      if (typeof error === 'string' && \n          (error.includes('[object Object]\" is not valid JSON') ||\n           error.includes('_storageChangeDispatcher') ||\n           error.includes('_storageChangeDispatcherCallback') ||\n           error.includes('content.js'))) {\n        event.preventDefault();\n        return;\n      }\n\n      // Also check the error message for these patterns\n      if (error && \n          typeof error === 'object' && \n          error.message &&\n          typeof error.message === 'string' &&\n          (error.message.includes('[object Object]\" is not valid JSON') ||\n           error.message.includes('_storageChangeDispatcher') ||\n           error.message.includes('_storageChangeDispatcherCallback'))) {\n        event.preventDefault();\n        return;\n      }\n    };\n\n    // Handle global errors\n    const handleError = (event: ErrorEvent) => {\n      const error = event.error;\n      const message = event.message;\n      \n      // Filter out extension-related errors\n      if (message && \n          (message.includes('content.js') ||\n           message.includes('_storageChangeDispatcher') ||\n           message.includes('[object Object]\" is not valid JSON'))) {\n        event.preventDefault();\n        return;\n      }\n    };\n\n    window.addEventListener('unhandledrejection', handleUnhandledRejection);\n    window.addEventListener('error', handleError);\n\n    return () => {\n      window.removeEventListener('unhandledrejection', handleUnhandledRejection);\n      window.removeEventListener('error', handleError);\n    };\n  }, []);\n\n  return null;\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/export/export-modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/layout/app-layout.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setIsNavigationVisible' is assigned a value but never used.","line":35,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * App Layout Component\n * Main layout structure matching the original mobile-first design\n */\n\n'use client';\n\nimport { useState } from 'react';\nimport { BottomNavigation } from './bottom-navigation';\nimport { PageHeader } from './page-header';\nimport { cn } from '@/lib/utils';\nimport { useIsDesktop } from '@/lib/hooks/useMediaQuery';\n\nimport { Sidebar } from './sidebar';\n\nexport interface AppLayoutProps {\n  children: React.ReactNode;\n  pageTitle?: string;\n  pageActions?: React.ReactNode;\n  showBackButton?: boolean;\n  onBack?: () => void;\n  currentPage?: string;\n  className?: string;\n}\n\nexport function AppLayout({\n  children,\n  pageTitle,\n  pageActions,\n  showBackButton = false,\n  onBack,\n  currentPage,\n  className,\n}: AppLayoutProps) {\n  const [isNavigationVisible, setIsNavigationVisible] = useState(true);\n  const isDesktop = useIsDesktop();\n\n  return (\n    <div className={cn(\n      'min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50',\n      isDesktop ? 'grid grid-cols-[256px_1fr]' : 'flex flex-col', // Dynamic layout\n      className\n    )}>\n      {/* Desktop Sidebar - only render on desktop */}\n      {isDesktop && <Sidebar />}\n\n      {/* Main Content Wrapper */}\n      <div className=\"flex flex-col min-h-screen\">\n        {/* Page Header */}\n        <PageHeader\n          title={pageTitle}\n          actions={pageActions}\n          showBackButton={showBackButton}\n          onBack={onBack}\n        />\n\n        {/* Main Content */}\n        <main className={cn(\n          'flex-1 overflow-x-hidden',\n          !isDesktop && 'pb-16', // Padding for mobile bottom nav only on mobile\n        )}>\n          <div className={cn(\n            'w-full max-w-7xl mx-auto',\n            'px-3 py-3 md:px-4 md:py-6',\n          )}>\n            {children}\n          </div>\n        </main>\n      </div>\n\n      {/* Bottom Navigation (Mobile Only) */}\n      {!isDesktop && (\n        <div className=\"fixed bottom-0 left-0 right-0 z-50\">\n          <BottomNavigation\n            currentPage={currentPage}\n            visible={isNavigationVisible}\n          />\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Layout for pages that need full width (like dashboard with charts)\nexport function FullWidthLayout({\n  children,\n  pageTitle,\n  pageActions,\n  showBackButton = false,\n  onBack,\n  currentPage,\n  className,\n}: AppLayoutProps) {\n  return (\n    <div className={cn(\n      'min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50',\n      'flex flex-col',\n      className\n    )}>\n      {/* Page Header */}\n      <PageHeader\n        title={pageTitle}\n        actions={pageActions}\n        showBackButton={showBackButton}\n        onBack={onBack}\n      />\n\n      {/* Main Content - Full Width */}\n      <main className={cn(\n        'flex-1 overflow-x-hidden',\n        'pb-16 md:pb-0', // Space for bottom nav\n      )}>\n        {children}\n      </main>\n\n      {/* Bottom Navigation (Mobile Only) */}\n      <div className=\"md:hidden\">\n        <BottomNavigation\n          currentPage={currentPage}\n          visible={true}\n        />\n      </div>\n    </div>\n  );\n}\n\n// Centered layout for forms and focused content\nexport function CenteredLayout({\n  children,\n  pageTitle,\n  pageActions,\n  showBackButton = false,\n  onBack,\n  maxWidth = 'md',\n  className,\n}: AppLayoutProps & {\n  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | '2xl';\n}) {\n  const maxWidths = {\n    sm: 'max-w-sm',\n    md: 'max-w-md',\n    lg: 'max-w-lg',\n    xl: 'max-w-xl',\n    '2xl': 'max-w-2xl',\n  };\n\n  return (\n    <div className={cn(\n      'min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50',\n      'flex flex-col',\n      className\n    )}>\n      {/* Page Header */}\n      <PageHeader\n        title={pageTitle}\n        actions={pageActions}\n        showBackButton={showBackButton}\n        onBack={onBack}\n      />\n\n      {/* Main Content - Centered */}\n      <main className={cn(\n        'flex-1 flex items-center justify-center',\n        'px-4 py-8',\n        'pb-24 md:pb-8', // Extra space for bottom nav\n      )}>\n        <div className={cn(\n          'w-full',\n          maxWidths[maxWidth]\n        )}>\n          {children}\n        </div>\n      </main>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/layout/bottom-navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/layout/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/layout/page-header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/layout/sidebar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Sun' is defined but never used.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Moon' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Badge' is defined but never used.","line":25,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\nimport { useEffect, useState, ComponentType } from 'react';\nimport { \n  loadFramerMotion, \n  StaticDiv,\n  type MotionDivProps\n} from '@/lib/optimization/dynamic-motion';\nimport { \n  Home, \n  FileSearch, \n  FileText, \n  History, \n  Settings,\n  LogOut,\n  Sun, // for theme toggle\n  Moon, // for theme toggle\n} from 'lucide-react';\nimport { useAuth } from '@/lib/hooks/useAuth';\nimport { useIsDesktop } from '@/lib/hooks/useMediaQuery';\nimport { authService } from '@/lib/services/auth-service';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { cn } from '@/lib/utils';\n\n// Re-using the same navigation items from bottom-navigation for consistency\nconst navigationItems = [\n  { id: 'dashboard', label: 'Dashboard', icon: Home, href: '/dashboard' },\n  { id: 'analysis', label: 'Analysis', icon: FileSearch, href: '/analysis' },\n  { id: 'reports', label: 'Reports', icon: FileText, href: '/reports' },\n  { id: 'history', label: 'History', icon: History, href: '/history' },\n  { id: 'settings', label: 'Settings', icon: Settings, href: '/settings' },\n];\n\nexport function Sidebar() {\n  const pathname = usePathname();\n  const { user } = useAuth();\n  const isDesktop = useIsDesktop();\n\n  // Dynamic motion loading\n  const [motionComponents, setMotionComponents] = useState<{\n    MotionDiv: ComponentType<MotionDivProps>;\n  }>({\n    MotionDiv: StaticDiv,\n  });\n\n  useEffect(() => {\n    // Load framer-motion only when sidebar is mounted\n    loadFramerMotion().then(({ motion }) => {\n      setMotionComponents({\n        MotionDiv: motion.div as ComponentType<MotionDivProps>,\n      });\n    });\n  }, []);\n\n  const { MotionDiv } = motionComponents;\n\n  const handleLogout = async () => {\n    await authService.signOut();\n    // This will trigger a redirect to the login page via the auth listener\n  };\n\n  // Don't render on mobile to prevent hydration mismatch\n  if (!isDesktop) {\n    return null;\n  }\n\n  return (\n    <aside className=\"flex flex-col bg-white border-r border-slate-200 h-screen sticky top-0\">\n      <div className=\"flex items-center justify-center h-16 border-b border-slate-200\">\n        <h1 className=\"text-xl font-bold text-blue-600\">Pay-Analyzer</h1>\n      </div>\n\n      <nav className=\"flex-1 px-4 py-6 space-y-2\">\n        {navigationItems.map((item) => {\n          const isActive = pathname.startsWith(item.href);\n          const Icon = item.icon;\n\n          return (\n            <Link key={item.id} href={item.href} className=\"block\">\n              <MotionDiv\n                whileHover={{ x: 5 }}\n                className={cn(\n                  'flex items-center px-3 py-2 rounded-lg text-sm font-medium transition-colors',\n                  isActive\n                    ? 'bg-blue-100 text-blue-700'\n                    : 'text-slate-600 hover:bg-slate-100 hover:text-slate-900'\n                )}\n              >\n                <Icon className=\"w-5 h-5 mr-3\" />\n                <span>{item.label}</span>\n              </MotionDiv>\n            </Link>\n          );\n        })}\n      </nav>\n\n      <div className=\"px-4 py-4 border-t border-slate-200\">\n        {user && (\n            <div className=\"flex items-center space-x-3 mb-4\">\n                <div className=\"w-10 h-10 rounded-full bg-blue-200 flex items-center justify-center\">\n                    <span className=\"font-semibold text-blue-700\">{user.email?.[0].toUpperCase()}</span>\n                </div>\n                <div className=\"flex-1 min-w-0\">\n                    <p className=\"text-sm font-semibold text-slate-800 truncate\">{user.email}</p>\n                    <p className=\"text-xs text-slate-500\">User</p>\n                </div>\n            </div>\n        )}\n        <Button variant=\"ghost\" className=\"w-full justify-start\" onClick={handleLogout}>\n          <LogOut className=\"w-5 h-5 mr-3\" />\n          Logout\n        </Button>\n      </div>\n    </aside>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/optimized/LazyChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/providers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/providers/theme-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/settings/storage-admin.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/bonus-tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/day-data-modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/empty-state.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/info-tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/interactive-calendar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dayDataMap' is assigned a value but never used.","line":33,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Interactive Calendar Component\n * Matches the original HTML system's calendar exactly\n */\n\n'use client';\n\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { ChevronLeft, ChevronRight } from 'lucide-react';\n\ninterface DayData {\n  date: string;\n  analysisId: string;\n  analysisName: string;\n  data: {\n    consignments: number;\n    expectedTotal: number;\n    paidAmount: number;\n    difference: number;\n    status: string;\n  };\n}\n\ninterface InteractiveCalendarProps {\n  onDayClick?: (date: Date, hasData: boolean) => void;\n  onAddDataClick?: (date: Date) => void;\n  className?: string;\n}\n\nexport function InteractiveCalendar({ onDayClick, onAddDataClick, className = '' }: InteractiveCalendarProps) {\n  const [currentMonth, setCurrentMonth] = useState(new Date());\n  const [datesWithData, setDatesWithData] = useState<Set<number>>(new Set());\n  const [dayDataMap, setDayDataMap] = useState<Map<number, DayData[]>>(new Map());\n  const [showTooltip, setShowTooltip] = useState<{ day: number; show: boolean }>({ day: 0, show: false });\n  const [selectedDay, setSelectedDay] = useState<number | null>(null);\n  const tooltipRef = useRef<HTMLDivElement>(null);\n\n  const monthNames = [\n    'January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'\n  ];\n\n  const dayHeaders = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];\n\n  const loadMonthData = useCallback(() => {\n    try {\n      const savedAnalyses = localStorage.getItem('pa:analyses:v9');\n      if (!savedAnalyses) {\n        setDatesWithData(new Set());\n        setDayDataMap(new Map());\n        return;\n      }\n\n      const analyses = JSON.parse(savedAnalyses);\n      const newDatesWithData = new Set<number>();\n      const newDayDataMap = new Map<number, DayData[]>();\n\n      Object.entries(analyses).forEach(([analysisId, analysis]: [string, unknown]) => {\n        // Type guard for analysis\n        if (analysis && typeof analysis === 'object' && 'dailyData' in analysis) {\n          const typedAnalysis = analysis as { dailyData?: Record<string, unknown>; period?: string };\n\n          if (typedAnalysis.dailyData) {\n            Object.entries(typedAnalysis.dailyData).forEach(([dateKey, dayData]: [string, unknown]) => {\n              const date = new Date(dateKey);\n\n              if (date.getMonth() === currentMonth.getMonth() &&\n                  date.getFullYear() === currentMonth.getFullYear()) {\n                const day = date.getDate();\n                newDatesWithData.add(day);\n\n                // Type guard for dayData\n                const typedDayData = dayData && typeof dayData === 'object' ? dayData as {\n                  consignments?: number;\n                  expectedTotal?: number;\n                  paidAmount?: number;\n                  status?: string;\n                } : {};\n\n                const dayDataList = newDayDataMap.get(day) || [];\n                dayDataList.push({\n                  date: dateKey,\n                  analysisId,\n                  analysisName: typedAnalysis.period || `Analysis ${analysisId}`,\n                  data: {\n                    consignments: typedDayData.consignments || 0,\n                    expectedTotal: typedDayData.expectedTotal || 0,\n                    paidAmount: typedDayData.paidAmount || 0,\n                    difference: (typedDayData.paidAmount || 0) - (typedDayData.expectedTotal || 0),\n                    status: typedDayData.status || 'complete'\n                  }\n                });\n                newDayDataMap.set(day, dayDataList);\n              }\n            });\n          }\n        }\n      });\n\n      setDatesWithData(newDatesWithData);\n      setDayDataMap(newDayDataMap);\n    } catch (error) {\n      console.error('Error loading calendar data:', error);\n      setDatesWithData(new Set());\n      setDayDataMap(new Map());\n    }\n  }, [currentMonth]);\n\n  // Load data for current month\n  useEffect(() => {\n    loadMonthData();\n  }, [loadMonthData]);\n\n  const navigateMonth = (direction: 'prev' | 'next') => {\n    const newMonth = new Date(currentMonth);\n    if (direction === 'prev') {\n      newMonth.setMonth(newMonth.getMonth() - 1);\n    } else {\n      // Only navigate to next month if it's not beyond current month\n      const now = new Date();\n      const nextMonth = new Date(currentMonth);\n      nextMonth.setMonth(nextMonth.getMonth() + 1);\n      \n      if (nextMonth.getFullYear() < now.getFullYear() || \n          (nextMonth.getFullYear() === now.getFullYear() && nextMonth.getMonth() <= now.getMonth())) {\n        newMonth.setMonth(newMonth.getMonth() + 1);\n      } else {\n        return; // Don't navigate beyond current month\n      }\n    }\n    setCurrentMonth(newMonth);\n    setSelectedDay(null);\n    setShowTooltip({ day: 0, show: false });\n  };\n\n  const isNextMonthDisabled = () => {\n    const now = new Date();\n    const nextMonth = new Date(currentMonth);\n    nextMonth.setMonth(nextMonth.getMonth() + 1);\n    \n    return nextMonth.getFullYear() > now.getFullYear() || \n           (nextMonth.getFullYear() === now.getFullYear() && nextMonth.getMonth() > now.getMonth());\n  };\n\n  const handleDayClick = (day: number, hasData: boolean) => {\n    const clickedDate = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), day);\n    const today = new Date();\n    \n    // Don't allow clicking on future dates\n    if (clickedDate > today) {\n      return;\n    }\n\n    setSelectedDay(day);\n\n    if (hasData) {\n      // Show day data or navigate to reports\n      onDayClick?.(clickedDate, true);\n    } else {\n      // Handle no-data day click\n      if (showTooltip.day === day && showTooltip.show) {\n        // Second click - add data\n        onAddDataClick?.(clickedDate);\n        setShowTooltip({ day: 0, show: false });\n      } else {\n        // First click - show tooltip\n        setShowTooltip({ day, show: true });\n        \n        // Auto-hide tooltip after 3 seconds\n        setTimeout(() => {\n          setShowTooltip(prev => prev.day === day ? { day: 0, show: false } : prev);\n        }, 3000);\n      }\n    }\n  };\n\n  const renderCalendar = () => {\n    const firstDay = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);\n    const lastDay = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 0);\n    const daysInMonth = lastDay.getDate();\n    const startingDayOfWeek = firstDay.getDay();\n    \n    const today = new Date();\n    const todayDay = today.getDate();\n    const isCurrentMonth = today.getMonth() === currentMonth.getMonth() && \n                          today.getFullYear() === currentMonth.getFullYear();\n\n    const days = [];\n\n    // Add empty cells for days before month starts\n    for (let i = 0; i < startingDayOfWeek; i++) {\n      days.push(<div key={`empty-${i}`} className=\"calendar-day\" />);\n    }\n\n    // Add days of month\n    for (let day = 1; day <= daysInMonth; day++) {\n      const dayDate = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), day);\n      const hasData = datesWithData.has(day);\n      const isToday = isCurrentMonth && day === todayDay;\n      const isFuture = dayDate > today;\n      const isSelected = selectedDay === day;\n      \n      let dayClasses = 'calendar-day';\n      if (isToday) dayClasses += ' today';\n      if (isFuture) dayClasses += ' future';\n      if (hasData) dayClasses += ' has-data clickable';\n      if (!hasData && !isFuture) dayClasses += ' no-data';\n      if (isSelected) dayClasses += ' selected';\n\n      days.push(\n        <div\n          key={day}\n          className={dayClasses}\n          onClick={() => handleDayClick(day, hasData)}\n          data-day={day}\n        >\n          {day}\n          {showTooltip.day === day && showTooltip.show && !hasData && (\n            <div \n              ref={tooltipRef}\n              className=\"calendar-tooltip show\"\n            >\n              <div style={{ fontWeight: 600, marginBottom: '4px' }}>\n                No data for {dayDate.toLocaleDateString()}\n              </div>\n              <div style={{ fontSize: '11px', color: 'rgba(255,255,255,0.8)' }}>\n                Click again to add data manually\n              </div>\n            </div>\n          )}\n        </div>\n      );\n    }\n\n    return days;\n  };\n\n  return (\n    <div className={`calendar-widget ${className}`}>\n      {/* Calendar Header */}\n      <div className=\"calendar-header\">\n        <div className=\"calendar-title\">\n          {monthNames[currentMonth.getMonth()]} {currentMonth.getFullYear()}\n        </div>\n        <div className=\"calendar-nav\">\n          <button\n            className=\"calendar-nav-btn\"\n            onClick={() => navigateMonth('prev')}\n          >\n            <ChevronLeft className=\"w-4 h-4\" />\n          </button>\n          <button\n            className={`calendar-nav-btn ${isNextMonthDisabled() ? 'disabled' : ''}`}\n            onClick={() => navigateMonth('next')}\n            disabled={isNextMonthDisabled()}\n          >\n            <ChevronRight className=\"w-4 h-4\" />\n          </button>\n        </div>\n      </div>\n\n      {/* Calendar Grid */}\n      <div className=\"calendar-grid\">\n        {/* Day Headers */}\n        {dayHeaders.map(day => (\n          <div key={day} className=\"calendar-day-header\">\n            {day}\n          </div>\n        ))}\n        \n        {/* Calendar Days */}\n        {renderCalendar()}\n      </div>\n\n      <style jsx>{`\n        .calendar-widget {\n          background: white;\n          border-radius: 12px;\n          padding: 16px;\n          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\n        }\n\n        .calendar-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 12px;\n        }\n\n        .calendar-title {\n          font-size: 14px;\n          font-weight: 700;\n          color: #1e293b;\n        }\n\n        .calendar-nav {\n          display: flex;\n          gap: 8px;\n        }\n\n        .calendar-nav-btn {\n          width: 32px;\n          height: 32px;\n          border: 2px solid #3b82f6;\n          background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);\n          color: white;\n          border-radius: 6px;\n          cursor: pointer;\n          transition: all 0.2s ease;\n          font-weight: 700;\n          box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);\n          display: flex;\n          align-items: center;\n          justify-content: center;\n        }\n\n        .calendar-nav-btn:hover:not(.disabled) {\n          transform: translateY(-1px);\n          box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);\n        }\n\n        .calendar-nav-btn.disabled {\n          background: #e2e8f0;\n          border-color: #e2e8f0;\n          color: #94a3b8;\n          cursor: not-allowed;\n          opacity: 0.6;\n        }\n\n        .calendar-grid {\n          display: grid;\n          grid-template-columns: repeat(7, 1fr);\n          gap: 4px;\n        }\n\n        .calendar-day-header {\n          font-size: 10px;\n          font-weight: 600;\n          color: #64748b;\n          text-align: center;\n          padding: 4px;\n        }\n\n        .calendar-day {\n          aspect-ratio: 1;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          font-size: 12px;\n          border-radius: 6px;\n          position: relative;\n          cursor: pointer;\n          transition: all 0.2s ease;\n        }\n\n        .calendar-day.has-data {\n          background: #f8fafc;\n          font-weight: 600;\n        }\n\n        .calendar-day.has-data::after {\n          content: '';\n          position: absolute;\n          bottom: 2px;\n          width: 4px;\n          height: 4px;\n          background: #3b82f6;\n          border-radius: 50%;\n        }\n\n        .calendar-day.today {\n          background: #3b82f6;\n          color: white;\n        }\n\n        .calendar-day.selected {\n          background: #1d4ed8;\n          color: white;\n          font-weight: 700;\n          box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);\n        }\n\n        .calendar-day.future {\n          background: #f1f5f9;\n          color: #94a3b8;\n          cursor: not-allowed;\n          opacity: 0.6;\n        }\n\n        .calendar-day.no-data {\n          position: relative;\n          cursor: pointer;\n        }\n\n        .calendar-day.no-data::before {\n          content: '+';\n          position: absolute;\n          top: 2px;\n          right: 2px;\n          width: 12px;\n          height: 12px;\n          background: #3b82f6;\n          color: white;\n          border-radius: 50%;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          font-size: 8px;\n          font-weight: 700;\n          opacity: 0;\n          transition: all 0.2s ease;\n        }\n\n        .calendar-day.no-data:hover::before {\n          opacity: 1;\n        }\n\n        .calendar-day:hover:not(.disabled):not(.future) {\n          background: #f1f5f9;\n          transform: scale(1.05);\n        }\n\n        .calendar-day.clickable:hover {\n          background: #3b82f6;\n          color: white;\n          transform: scale(1.05);\n        }\n\n        .calendar-tooltip {\n          position: absolute;\n          background: #1e293b;\n          color: white;\n          padding: 8px 12px;\n          border-radius: 6px;\n          font-size: 12px;\n          z-index: 9999;\n          opacity: 0;\n          transform: translateY(-4px);\n          transition: all 0.2s ease;\n          pointer-events: none;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n          max-width: 250px;\n          top: 100%;\n          left: 50%;\n          transform: translateX(-50%) translateY(4px);\n          margin-top: 4px;\n          letter-spacing: 0.02em;\n        }\n\n        .calendar-tooltip::before {\n          content: '';\n          position: absolute;\n          bottom: 100%;\n          left: 50%;\n          transform: translateX(-50%);\n          width: 0;\n          height: 0;\n          border-left: 4px solid transparent;\n          border-right: 4px solid transparent;\n          border-bottom: 4px solid #1e293b;\n        }\n\n        .calendar-tooltip.show {\n          opacity: 1;\n          visibility: visible;\n          transform: translateX(-50%) translateY(0);\n        }\n      `}</style>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/offline-indicator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isOffline' is assigned a value but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState, useEffect } from 'react';\nimport { hasValidSupabaseConfig } from '@/lib/utils/supabase-cleanup';\n\nexport function OfflineIndicator() {\n  const [isOffline, setIsOffline] = useState(false);\n  const [showIndicator, setShowIndicator] = useState(false);\n\n  useEffect(() => {\n    // Check if we're in offline mode due to missing Supabase config\n    const hasInvalidConfig = !hasValidSupabaseConfig();\n    \n    // Check if we're actually offline\n    const handleOnline = () => setIsOffline(false);\n    const handleOffline = () => setIsOffline(true);\n\n    setIsOffline(!navigator.onLine || hasInvalidConfig);\n    setShowIndicator(hasInvalidConfig || !navigator.onLine);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  if (!showIndicator) return null;\n\n  const hasInvalidConfig = !hasValidSupabaseConfig();\n\n  return (\n    <div className=\"fixed top-4 right-4 z-50 max-w-sm\">\n      <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-3 shadow-lg\">\n        <div className=\"flex items-center gap-2\">\n          <div className=\"flex-shrink-0\">\n            {hasInvalidConfig ? (\n              <svg className=\"w-4 h-4 text-yellow-600\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                <path fillRule=\"evenodd\" d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\" clipRule=\"evenodd\" />\n              </svg>\n            ) : (\n              <svg className=\"w-4 h-4 text-yellow-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M18.364 5.636l-3.536 3.536m0 5.656l3.536 3.536M9.172 9.172L5.636 5.636m3.536 9.192L5.636 18.364M12 2.196l1.412 2.824 3.118.454-2.254 2.197.532 3.104L12 9.735l-2.808 1.04.532-3.104-2.254-2.197 3.118-.454L12 2.196z\" />\n              </svg>\n            )}\n          </div>\n          \n          <div className=\"flex-1 min-w-0\">\n            <p className=\"text-sm font-medium text-yellow-800\">\n              {hasInvalidConfig ? 'Demo Mode' : 'Offline Mode'}\n            </p>\n            <p className=\"text-xs text-yellow-700 mt-1\">\n              {hasInvalidConfig \n                ? 'Using local storage only. Check SETUP.md to enable online features.' \n                : 'No internet connection. Using local storage.'}\n            </p>\n          </div>\n          \n          <button\n            onClick={() => setShowIndicator(false)}\n            className=\"flex-shrink-0 text-yellow-600 hover:text-yellow-800\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/print-test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/recovery-banner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/themed-button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/themed-card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/components/ui/toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/hooks/use-analysis-steps.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UploadedFile' is defined but never used.","line":10,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { toast } from '@/lib/utils/toast';\nimport { ManualEntry } from '@/types/core';\n\nexport type InputMethod = 'upload' | 'manual';\n\n// Type definitions for step data\ninterface UploadedFile {\n  name: string;\n  size: number;\n  type: string;\n  lastModified: number;\n}\n\n\ninterface AnalysisData {\n  id: string;\n  period: string;\n  status: string;\n  createdAt: string;\n  totalDays: number;\n  source: string;\n  [key: string]: unknown;\n}\n\nexport interface StepState {\n  currentStep: number;\n  totalSteps: number;\n  inputMethod: InputMethod;\n  uploadedFiles: File[];\n  manualEntries: ManualEntry[];\n  hasBeenAnalyzed: boolean;\n  lastAnalysisData: AnalysisData | null;\n}\n\nexport interface UseAnalysisStepsReturn {\n  // State\n  currentStep: number;\n  totalSteps: number;\n  inputMethod: InputMethod;\n  uploadedFiles: File[];\n  manualEntries: ManualEntry[];\n  hasBeenAnalyzed: boolean;\n  lastAnalysisData: AnalysisData | null;\n  \n  // Actions\n  setStep: (stepNumber: number) => void;\n  setInputMethod: (method: InputMethod) => void;\n  setUploadedFiles: (files: File[]) => void;\n  setManualEntries: (entries: ManualEntry[]) => void;\n  setHasBeenAnalyzed: (analyzed: boolean) => void;\n  setLastAnalysisData: (data: AnalysisData | null) => void;\n  \n  // Validation\n  canProgressToStep: (stepNumber: number) => boolean;\n  \n  // Auto-progression\n  handleFilesUploaded: (files: File[]) => void;\n  handleAnalysisStarted: () => void;\n  handleNewAnalysis: () => void;\n  \n  // Step content visibility\n  showUploadSection: boolean;\n  showValidateSection: boolean;\n  showAnalyzeSection: boolean;\n}\n\nconst TOTAL_STEPS = 3;\n\nexport function useAnalysisSteps(): UseAnalysisStepsReturn {\n  // Core state\n  const [currentStep, setCurrentStep] = useState<number>(1);\n  const [inputMethod, setInputMethod] = useState<InputMethod>('upload');\n  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);\n  const [manualEntries, setManualEntries] = useState<ManualEntry[]>([]);\n  const [hasBeenAnalyzed, setHasBeenAnalyzed] = useState<boolean>(false);\n  const [lastAnalysisData, setLastAnalysisData] = useState<AnalysisData | null>(null);\n\n  // Validation function - matches original logic\n  const canProgressToStep = useCallback((stepNumber: number): boolean => {\n    switch (stepNumber) {\n      case 1: \n        return true; // Always can go to step 1\n      case 2:\n        // Allow step 2 if we have data OR if we've previously analyzed data\n        return uploadedFiles.length > 0 || manualEntries.length > 0 || hasBeenAnalyzed || !!lastAnalysisData;\n      case 3:\n        // Allow step 3 if we have data OR if we've previously analyzed data\n        return uploadedFiles.length > 0 || manualEntries.length > 0 || hasBeenAnalyzed || !!lastAnalysisData;\n      default: \n        return false;\n    }\n  }, [uploadedFiles.length, manualEntries.length, hasBeenAnalyzed, lastAnalysisData]);\n\n  // Main setStep function - matches original logic\n  const setStep = useCallback((stepNumber: number) => {\n    if (stepNumber >= 1 && stepNumber <= TOTAL_STEPS) {\n      if (!canProgressToStep(stepNumber)) {\n        toast.warning('Complete previous steps first');\n        return;\n      }\n      \n      setCurrentStep(stepNumber);\n      console.log(`📍 Step changed to: ${stepNumber}`);\n      \n      // Step-specific initialization logic\n      if (stepNumber === 2) {\n        console.log('📊 Entering validation step');\n      } else if (stepNumber === 3) {\n        console.log('🚀 Entering analysis step');\n        // Try to load previous analysis if we don't have current analysis data\n        if (!lastAnalysisData && !hasBeenAnalyzed) {\n          // In a real app, you might load from localStorage or API here\n          console.log('📊 Checking for previous analysis data');\n        }\n      }\n    }\n  }, [canProgressToStep, lastAnalysisData, hasBeenAnalyzed]);\n\n  // Auto-progression handlers\n  const handleFilesUploaded = useCallback((files: File[]) => {\n    setUploadedFiles(files);\n    \n    // Auto-progress to step 2 when files are uploaded (matches original logic)\n    if (files.length > 0 && currentStep === 1) {\n      setTimeout(() => {\n        setStep(2);\n        toast.success('Files uploaded! Ready to validate');\n      }, 500);\n    }\n    \n    // Go back to step 1 if no files remain and no analysis data exists\n    if (files.length === 0 && currentStep > 1 && !lastAnalysisData) {\n      setStep(1);\n      toast.info('No files remaining. Upload files to continue');\n    }\n  }, [currentStep, lastAnalysisData, setStep]);\n\n  const handleAnalysisStarted = useCallback(() => {\n    const hasFiles = uploadedFiles.length > 0;\n    const hasManualData = manualEntries.length > 0;\n    \n    if (!hasFiles && !hasManualData) {\n      toast.error('No data to analyze');\n      return;\n    }\n    \n    // Progress to step 3 when analysis starts (matches original logic)\n    setStep(3);\n  }, [uploadedFiles.length, manualEntries.length, setStep]);\n\n  const handleNewAnalysis = useCallback(() => {\n    // Clear all data and reset to step 1 (matches original logic)\n    setCurrentStep(1);\n    setUploadedFiles([]);\n    setManualEntries([]);\n    setHasBeenAnalyzed(false);\n    setLastAnalysisData(null);\n    toast.success('Ready for new analysis');\n  }, []);\n\n  // Section visibility based on current step\n  const showUploadSection = currentStep === 1;\n  const showValidateSection = currentStep === 2;\n  const showAnalyzeSection = currentStep === 3;\n\n  // Auto-progression for manual entries\n  useEffect(() => {\n    // Automatically progress to Step 2 after adding manual entry (matches original logic)\n    if (inputMethod === 'manual' && manualEntries.length > 0 && currentStep === 1) {\n      setTimeout(() => {\n        setStep(2);\n        toast.success('Entry added! Review your data');\n      }, 300);\n    }\n  }, [manualEntries.length, currentStep, inputMethod, setStep]);\n\n  return {\n    // State\n    currentStep,\n    totalSteps: TOTAL_STEPS,\n    inputMethod,\n    uploadedFiles,\n    manualEntries,\n    hasBeenAnalyzed,\n    lastAnalysisData,\n    \n    // Actions\n    setStep,\n    setInputMethod,\n    setUploadedFiles,\n    setManualEntries,\n    setHasBeenAnalyzed,\n    setLastAnalysisData,\n    \n    // Validation\n    canProgressToStep,\n    \n    // Auto-progression\n    handleFilesUploaded,\n    handleAnalysisStarted,\n    handleNewAnalysis,\n    \n    // Section visibility\n    showUploadSection,\n    showValidateSection,\n    showAnalyzeSection,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/hooks/use-compressed-storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/hooks/use-payment-tooltips.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'bonuses' is assigned a value but never used.","line":32,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useMemo } from 'react';\nimport { DEFAULT_PAYMENT_RULES } from '@/lib/constants';\nimport { getApplicableBonuses, calculateExpectedPayment } from '@/lib/utils/payment-utils';\n\nexport function usePaymentTooltips(selectedDate?: Date, consignments?: number) {\n  const tooltipContent = useMemo(() => {\n    const date = selectedDate || new Date();\n    const dayOfWeek = date.getDay();\n    const consignmentCount = consignments || 0;\n    \n    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    const dayName = dayNames[dayOfWeek];\n    \n    const isSunday = dayOfWeek === 0;\n    const isSaturday = dayOfWeek === 6;\n    const isMonday = dayOfWeek === 1;\n    \n    // Calculate base rate tooltip\n    let rateText = 'Rest day - no work';\n    if (!isSunday) {\n      const rate = isSaturday ? DEFAULT_PAYMENT_RULES.saturdayRate : DEFAULT_PAYMENT_RULES.weekdayRate;\n      rateText = `You earn £${rate.toFixed(2)} per delivery`;\n      if (consignmentCount > 0) {\n        const totalBase = consignmentCount * rate;\n        rateText += ` (${consignmentCount} × £${rate.toFixed(2)} = £${totalBase.toFixed(2)})`;\n      }\n    }\n    \n    // Calculate bonus tooltips\n    const bonuses = getApplicableBonuses(dayOfWeek);\n    \n    let earlyText = 'No bonus today';\n    let attendanceText = 'No bonus today';\n    let unloadingText = 'No bonus today';\n    \n    if (!isSunday) {\n      // Unloading bonus tooltip\n      if (isMonday) {\n        unloadingText = 'No unloading bonus on Monday';\n      } else {\n        unloadingText = `£${DEFAULT_PAYMENT_RULES.unloadingBonus.toFixed(2)} bonus today`;\n      }\n      \n      // Weekday bonuses (not Saturday or Sunday)\n      if (!isSaturday) {\n        earlyText = `£${DEFAULT_PAYMENT_RULES.earlyBonus.toFixed(2)} bonus today`;\n        attendanceText = `£${DEFAULT_PAYMENT_RULES.attendanceBonus.toFixed(2)} bonus today`;\n      } else {\n        earlyText = 'No early bonus on Saturday';\n        attendanceText = 'No attendance bonus on Saturday';\n      }\n    }\n    \n    // Calculate total expected tooltip\n    let totalText = 'No earnings expected today';\n    if (!isSunday && consignmentCount > 0) {\n      const calculation = calculateExpectedPayment(date, consignmentCount);\n      totalText = `Expected total: £${calculation.expectedAmount.toFixed(2)}`;\n      if (calculation.totalBonuses > 0) {\n        totalText += ` (Base: £${calculation.basePayment.toFixed(2)} + Bonuses: £${calculation.totalBonuses.toFixed(2)})`;\n      }\n    }\n    \n    return {\n      dayName,\n      isSunday,\n      isSaturday, \n      isMonday,\n      baseAmount: rateText,\n      earlyArrive: earlyText,\n      attendance: attendanceText,\n      unloading: unloadingText,\n      expectedTotal: totalText,\n    };\n  }, [selectedDate, consignments]);\n  \n  return tooltipContent;\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/hooks/use-timezones.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/hooks/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/contexts/theme-context.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/entities/analysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/entities/daily-entry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/entities/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/entities/payment-rules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/schemas/manual-entry-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/services/file-fingerprint-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/services/file-validation-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":259,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":259,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * File Validation Service\n * Advanced file validation with update detection, matching original HTML system\n */\n\nexport interface FileMetadata {\n  name: string;\n  size: number;\n  type: string;\n  lastModified: number;\n  hash?: string;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  isUpdated?: boolean;\n  duplicateFiles?: FileMetadata[];\n  existingAnalysis?: string;\n}\n\nexport interface FileValidationOptions {\n  maxFileSize: number; // in bytes\n  allowedTypes: string[];\n  checkForUpdates: boolean;\n  checkForDuplicates: boolean;\n}\n\nexport interface StoredAnalysisData {\n  id: string;\n  files?: FileMetadata[];\n  [key: string]: unknown;\n}\n\nexport class FileValidationService {\n  private static readonly DEFAULT_OPTIONS: FileValidationOptions = {\n    maxFileSize: 50 * 1024 * 1024, // 50MB\n    allowedTypes: ['application/pdf'],\n    checkForUpdates: true,\n    checkForDuplicates: true,\n  };\n\n  /**\n   * Validate uploaded files with comprehensive checks\n   */\n  async validateFiles(\n    files: File[], \n    options: Partial<FileValidationOptions> = {}\n  ): Promise<ValidationResult> {\n    const config = { ...FileValidationService.DEFAULT_OPTIONS, ...options };\n    const result: ValidationResult = {\n      isValid: true,\n      errors: [],\n      warnings: [],\n    };\n\n    // Basic validation\n    this.validateBasicRequirements(files, config, result);\n    \n    if (config.checkForDuplicates) {\n      this.checkForDuplicateFiles(files, result);\n    }\n\n    if (config.checkForUpdates) {\n      await this.checkForFileUpdates(files, result);\n    }\n\n    // Additional PDF-specific validation\n    await this.validatePDFFiles(files, result);\n\n    result.isValid = result.errors.length === 0;\n    return result;\n  }\n\n  /**\n   * Check if files have been updated since last analysis\n   */\n  async checkForFileUpdates(files: File[], result: ValidationResult): Promise<void> {\n    try {\n      const savedAnalyses = localStorage.getItem('pa:analyses:v9');\n      if (!savedAnalyses) return;\n\n      const analyses = JSON.parse(savedAnalyses);\n      const fileMetadata = await this.extractFileMetadata(files);\n      \n      let hasUpdates = false;\n      const updatedFiles: string[] = [];\n\n      // Check each file against existing analyses\n      for (const file of fileMetadata) {\n        const existingAnalysis = this.findAnalysisWithFile(analyses, file);\n        \n        if (existingAnalysis) {\n          const existingFile = existingAnalysis.files?.find(\n            (f: FileMetadata) => f.name === file.name && f.size === file.size\n          );\n\n          if (existingFile && file.lastModified > existingFile.lastModified) {\n            hasUpdates = true;\n            updatedFiles.push(file.name);\n            \n            console.log(`📄 File ${file.name} updated:`, {\n              previous: new Date(existingFile.lastModified).toLocaleString(),\n              current: new Date(file.lastModified).toLocaleString(),\n            });\n          }\n        }\n      }\n\n      if (hasUpdates) {\n        result.isUpdated = true;\n        result.warnings.push(\n          `File updates detected: ${updatedFiles.join(', ')}. Consider re-processing to get latest data.`\n        );\n      }\n    } catch (error) {\n      console.error('Error checking file updates:', error);\n      result.warnings.push('Unable to check for file updates');\n    }\n  }\n\n  /**\n   * Find existing analysis that contains similar files\n   */\n  findExistingAnalysis(files: File[]): string | null {\n    try {\n      const savedAnalyses = localStorage.getItem('pa:analyses:v9');\n      if (!savedAnalyses) return null;\n\n      const analyses = JSON.parse(savedAnalyses);\n      const currentFileSignatures = files.map(f => ({\n        name: f.name,\n        size: f.size,\n      }));\n\n      for (const [analysisId, analysis] of Object.entries(analyses)) {\n        const analysisData = analysis as StoredAnalysisData;\n        if (!analysisData.files) continue;\n\n        const analysisFileSignatures = analysisData.files.map((f: FileMetadata) => ({\n          name: f.name,\n          size: f.size,\n        }));\n\n        // Check if file signatures match (same files)\n        if (this.arraysEqual(currentFileSignatures, analysisFileSignatures)) {\n          return analysisId;\n        }\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error finding existing analysis:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Generate file fingerprint for duplicate detection\n   */\n  async generateFileFingerprint(file: File): Promise<string> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    } catch (error) {\n      console.error('Error generating file fingerprint:', error);\n      // Fallback to simple hash\n      return `${file.name}_${file.size}_${file.lastModified}`;\n    }\n  }\n\n  /**\n   * Validate basic file requirements\n   */\n  private validateBasicRequirements(\n    files: File[], \n    config: FileValidationOptions, \n    result: ValidationResult\n  ): void {\n    if (files.length === 0) {\n      result.errors.push('No files selected');\n      return;\n    }\n\n    for (const file of files) {\n      // Size validation\n      if (file.size > config.maxFileSize) {\n        result.errors.push(\n          `File \"${file.name}\" is too large (${this.formatFileSize(file.size)}). Maximum size is ${this.formatFileSize(config.maxFileSize)}`\n        );\n      }\n\n      if (file.size === 0) {\n        result.errors.push(`File \"${file.name}\" is empty`);\n      }\n\n      // Type validation\n      if (!config.allowedTypes.includes(file.type)) {\n        result.errors.push(\n          `File \"${file.name}\" has invalid type (${file.type || 'unknown'}). Allowed types: ${config.allowedTypes.join(', ')}`\n        );\n      }\n\n      // Name validation\n      if (!file.name || file.name.trim() === '') {\n        result.errors.push('File has no name');\n      }\n    }\n  }\n\n  /**\n   * Check for duplicate files in current selection\n   */\n  private checkForDuplicateFiles(files: File[], result: ValidationResult): void {\n    const seen = new Set<string>();\n    const duplicates: FileMetadata[] = [];\n\n    for (const file of files) {\n      const signature = `${file.name}_${file.size}`;\n      \n      if (seen.has(signature)) {\n        duplicates.push({\n          name: file.name,\n          size: file.size,\n          type: file.type,\n          lastModified: file.lastModified,\n        });\n      } else {\n        seen.add(signature);\n      }\n    }\n\n    if (duplicates.length > 0) {\n      result.duplicateFiles = duplicates;\n      result.warnings.push(\n        `Duplicate files detected: ${duplicates.map(f => f.name).join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Validate PDF files specifically\n   */\n  private async validatePDFFiles(files: File[], result: ValidationResult): Promise<void> {\n    const pdfFiles = files.filter(f => f.type === 'application/pdf');\n    \n    for (const file of pdfFiles) {\n      try {\n        // Check if file is a valid PDF by reading header\n        const header = await this.readFileHeader(file, 8);\n        const pdfMagic = new Uint8Array([0x25, 0x50, 0x44, 0x46]); // %PDF\n        \n        if (!this.arrayStartsWith(header, pdfMagic)) {\n          result.errors.push(`File \"${file.name}\" is not a valid PDF file`);\n        }\n      } catch (error) {\n        result.warnings.push(`Unable to validate PDF structure for \"${file.name}\"`);\n      }\n    }\n  }\n\n  /**\n   * Extract metadata from files\n   */\n  private async extractFileMetadata(files: File[]): Promise<FileMetadata[]> {\n    return Promise.all(\n      files.map(async (file) => ({\n        name: file.name,\n        size: file.size,\n        type: file.type,\n        lastModified: file.lastModified,\n        hash: await this.generateFileFingerprint(file),\n      }))\n    );\n  }\n\n  /**\n   * Find analysis that contains a specific file\n   */\n  private findAnalysisWithFile(analyses: Record<string, StoredAnalysisData>, fileMetadata: FileMetadata): StoredAnalysisData | null {\n    for (const analysis of Object.values(analyses)) {\n      const analysisData = analysis;\n      if (analysisData.files) {\n        const hasFile = analysisData.files.some(\n          (f: FileMetadata) => f.name === fileMetadata.name && f.size === fileMetadata.size\n        );\n        if (hasFile) return analysisData;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Read file header bytes\n   */\n  private async readFileHeader(file: File, bytes: number): Promise<Uint8Array> {\n    const slice = file.slice(0, bytes);\n    const buffer = await slice.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n\n  /**\n   * Check if array starts with another array\n   */\n  private arrayStartsWith(array: Uint8Array, prefix: Uint8Array): boolean {\n    if (array.length < prefix.length) return false;\n    for (let i = 0; i < prefix.length; i++) {\n      if (array[i] !== prefix[i]) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if two arrays are equal\n   */\n  private arraysEqual(a: unknown[], b: unknown[]): boolean {\n    if (a.length !== b.length) return false;\n    return a.every((val, index) => \n      typeof val === 'object' ? \n        JSON.stringify(val) === JSON.stringify(b[index]) : \n        val === b[index]\n    );\n  }\n\n  /**\n   * Format file size for display\n   */\n  private formatFileSize(bytes: number): string {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n}\n\n// Export singleton instance\nexport const fileValidationService = new FileValidationService();","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/services/payment-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/services/validation-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DateRange' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ValidationService Domain Service\n * Handles validation of business rules and data integrity\n */\n\nimport { Analysis } from '../entities/analysis';\nimport { DailyEntry } from '../entities/daily-entry';\nimport { PaymentRules } from '../entities/payment-rules';\nimport { Money } from '../value-objects/money';\nimport { DateRange } from '../value-objects/date-range';\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n}\n\nexport interface ValidationError {\n  code: string;\n  message: string;\n  field?: string;\n  value?: unknown;\n}\n\nexport interface ValidationWarning {\n  code: string;\n  message: string;\n  field?: string;\n  value?: unknown;\n}\n\nexport class ValidationService {\n  validateAnalysis(analysis: Analysis): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    // Check if analysis has daily entries\n    if (analysis.dailyEntries.length === 0) {\n      errors.push({\n        code: 'NO_DAILY_ENTRIES',\n        message: 'Analysis must contain at least one daily entry',\n      });\n    }\n\n    // Check period coverage\n    const missingDays = this.findMissingWorkingDays(analysis);\n    if (missingDays.length > 0) {\n      warnings.push({\n        code: 'MISSING_WORKING_DAYS',\n        message: `Missing entries for working days: ${missingDays.map(d => d.toDateString()).join(', ')}`,\n        value: missingDays,\n      });\n    }\n\n    // Check for duplicate entries\n    const duplicates = this.findDuplicateEntries(analysis.dailyEntries);\n    if (duplicates.length > 0) {\n      errors.push({\n        code: 'DUPLICATE_ENTRIES',\n        message: `Duplicate entries found for dates: ${duplicates.map(d => d.toDateString()).join(', ')}`,\n        value: duplicates,\n      });\n    }\n\n    // Validate individual daily entries\n    analysis.dailyEntries.forEach(entry => {\n      const entryValidation = this.validateDailyEntry(entry);\n      errors.push(...entryValidation.errors);\n      warnings.push(...entryValidation.warnings);\n    });\n\n    // Check for significant payment discrepancies\n    const largeDiscrepancies = this.findLargeDiscrepancies(analysis.dailyEntries);\n    if (largeDiscrepancies.length > 0) {\n      warnings.push({\n        code: 'LARGE_DISCREPANCIES',\n        message: `Large payment discrepancies found on ${largeDiscrepancies.length} days`,\n        value: largeDiscrepancies,\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  validateDailyEntry(entry: DailyEntry): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    // Check if it's a working day\n    if (!entry.isWorkingDay && entry.consignments.count > 0) {\n      warnings.push({\n        code: 'SUNDAY_CONSIGNMENTS',\n        message: 'Consignments recorded on Sunday (non-working day)',\n        field: 'consignments',\n        value: entry.consignments.count,\n      });\n    }\n\n    // Check for zero consignments with payment\n    if (entry.consignments.count === 0 && entry.paidAmount.isPositive()) {\n      warnings.push({\n        code: 'PAYMENT_WITHOUT_CONSIGNMENTS',\n        message: 'Payment received with zero consignments',\n        field: 'paidAmount',\n        value: entry.paidAmount.amount,\n      });\n    }\n\n    // Check for extremely high consignment counts\n    if (entry.consignments.count > 200) {\n      warnings.push({\n        code: 'HIGH_CONSIGNMENT_COUNT',\n        message: 'Unusually high consignment count',\n        field: 'consignments',\n        value: entry.consignments.count,\n      });\n    }\n\n    // Check for extremely high payment amounts\n    if (entry.paidAmount.amount > 1000) {\n      warnings.push({\n        code: 'HIGH_PAYMENT_AMOUNT',\n        message: 'Unusually high payment amount',\n        field: 'paidAmount',\n        value: entry.paidAmount.amount,\n      });\n    }\n\n    // Check for negative payment amounts\n    if (entry.paidAmount.isNegative()) {\n      errors.push({\n        code: 'NEGATIVE_PAYMENT',\n        message: 'Payment amount cannot be negative',\n        field: 'paidAmount',\n        value: entry.paidAmount.amount,\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  validatePaymentRules(rules: PaymentRules): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    // Check for negative rates\n    if (rules.weekdayRate.isNegative()) {\n      errors.push({\n        code: 'NEGATIVE_WEEKDAY_RATE',\n        message: 'Weekday rate cannot be negative',\n        field: 'weekdayRate',\n        value: rules.weekdayRate.amount,\n      });\n    }\n\n    if (rules.saturdayRate.isNegative()) {\n      errors.push({\n        code: 'NEGATIVE_SATURDAY_RATE',\n        message: 'Saturday rate cannot be negative',\n        field: 'saturdayRate',\n        value: rules.saturdayRate.amount,\n      });\n    }\n\n    // Check for negative bonuses\n    if (rules.unloadingBonus.isNegative()) {\n      errors.push({\n        code: 'NEGATIVE_UNLOADING_BONUS',\n        message: 'Unloading bonus cannot be negative',\n        field: 'unloadingBonus',\n        value: rules.unloadingBonus.amount,\n      });\n    }\n\n    if (rules.attendanceBonus.isNegative()) {\n      errors.push({\n        code: 'NEGATIVE_ATTENDANCE_BONUS',\n        message: 'Attendance bonus cannot be negative',\n        field: 'attendanceBonus',\n        value: rules.attendanceBonus.amount,\n      });\n    }\n\n    if (rules.earlyBonus.isNegative()) {\n      errors.push({\n        code: 'NEGATIVE_EARLY_BONUS',\n        message: 'Early bonus cannot be negative',\n        field: 'earlyBonus',\n        value: rules.earlyBonus.amount,\n      });\n    }\n\n    // Check for unusual rate differences\n    const rateDifference = rules.saturdayRate.subtract(rules.weekdayRate);\n    if (rateDifference.isNegative()) {\n      warnings.push({\n        code: 'SATURDAY_RATE_LOWER',\n        message: 'Saturday rate is lower than weekday rate',\n        value: { weekday: rules.weekdayRate.amount, saturday: rules.saturdayRate.amount },\n      });\n    }\n\n    // Check for extremely high values\n    if (rules.weekdayRate.amount > 10) {\n      warnings.push({\n        code: 'HIGH_WEEKDAY_RATE',\n        message: 'Weekday rate seems unusually high',\n        field: 'weekdayRate',\n        value: rules.weekdayRate.amount,\n      });\n    }\n\n    if (rules.saturdayRate.amount > 15) {\n      warnings.push({\n        code: 'HIGH_SATURDAY_RATE',\n        message: 'Saturday rate seems unusually high',\n        field: 'saturdayRate',\n        value: rules.saturdayRate.amount,\n      });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  private findMissingWorkingDays(analysis: Analysis): Date[] {\n    const workingDays = analysis.period.getWorkingDays();\n    const entryDates = new Set(\n      analysis.dailyEntries.map(entry => entry.date.toDateString())\n    );\n\n    return workingDays.filter(\n      day => !entryDates.has(day.toDateString())\n    );\n  }\n\n  private findDuplicateEntries(entries: readonly DailyEntry[]): Date[] {\n    const dateStrings = entries.map(entry => entry.date.toDateString());\n    const duplicates = new Set<string>();\n    const seen = new Set<string>();\n\n    for (const dateString of dateStrings) {\n      if (seen.has(dateString)) {\n        duplicates.add(dateString);\n      } else {\n        seen.add(dateString);\n      }\n    }\n\n    return Array.from(duplicates).map(dateString => new Date(dateString));\n  }\n\n  private findLargeDiscrepancies(entries: readonly DailyEntry[]): DailyEntry[] {\n    const threshold = Money.from(50); // £50 threshold\n    return entries.filter(entry => \n      entry.difference.amount > threshold.amount || \n      entry.difference.amount < -threshold.amount\n    );\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/value-objects/consignment-count.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/value-objects/date-range.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/value-objects/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/domain/value-objects/money.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/hooks/use-online-status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/hooks/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/hooks/useMediaQuery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/infrastructure/pdf/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/infrastructure/pdf/invoice-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filename' is defined but never used.","line":32,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'foundAmount' is assigned a value but never used.","line":216,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":216,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Invoice PDF Parser\n * Extracts payment amounts and service details from invoices\n * Based on the original system's parsing logic\n */\n\nimport { PDFParserBase } from './pdf-parser-base';\nimport type { ParsedPDFData } from '../../../types/core';\n\nexport interface InvoiceEntry {\n  date: Date;\n  time?: string;\n  amount: number;\n  serviceType?: string;\n  description?: string;\n}\n\nexport interface InvoiceData {\n  entries: InvoiceEntry[];\n  totalAmount: number;\n  documentTotal: number | null;\n  isValid: boolean;\n  dates: Date[];\n  pickupServices: InvoiceEntry[];\n  extraDrops: InvoiceEntry[];\n  validationMessage?: string;\n}\n\nexport class InvoiceParser extends PDFParserBase<InvoiceData> {\n  protected fileTypeIdentifiers = ['self', 'invoice', 'bill'];\n\n  protected async extractData(rawData: ParsedPDFData, filename?: string): Promise<InvoiceData> {\n    const entries: InvoiceEntry[] = [];\n    const pickupServices: InvoiceEntry[] = [];\n    const extraDrops: InvoiceEntry[] = [];\n    \n    // Combine all pages for processing\n    const fullText = rawData.text;\n    \n    // Extract document total first\n    const documentTotal = this.extractDocumentTotal(fullText);\n    \n    // Extract individual entries\n    const extractedEntries = this.extractEntries(fullText);\n    \n    // Categorize entries\n    for (const entry of extractedEntries) {\n      if (entry.serviceType?.toLowerCase().includes('pickup')) {\n        pickupServices.push(entry);\n      } else if (entry.description?.toLowerCase().includes('extra drop')) {\n        extraDrops.push(entry);\n      } else {\n        entries.push(entry);\n      }\n    }\n\n    // Calculate total from entries\n    const calculatedTotal = extractedEntries.reduce((sum, entry) => sum + entry.amount, 0);\n    \n    // Validation\n    const isValid = this.validateTotals(calculatedTotal, documentTotal);\n    const validationMessage = this.getValidationMessage(calculatedTotal, documentTotal);\n    \n    // Extract unique dates\n    const dates = Array.from(\n      new Map(extractedEntries.map(entry => [entry.date.getTime(), entry.date])).values()\n    ).sort((a, b) => a.getTime() - b.getTime());\n\n    return {\n      entries: entries.sort((a, b) => a.date.getTime() - b.date.getTime()),\n      totalAmount: calculatedTotal,\n      documentTotal,\n      isValid,\n      dates,\n      pickupServices,\n      extraDrops,\n      validationMessage,\n    };\n  }\n\n  protected async validateData(data: InvoiceData): Promise<{\n    isValid: boolean;\n    error?: string;\n    warnings?: string[];\n  }> {\n    const warnings: string[] = [];\n\n    // Check if any entries were extracted\n    if (data.entries.length === 0 && data.pickupServices.length === 0 && data.extraDrops.length === 0) {\n      return {\n        isValid: false,\n        error: 'No payment entries found in invoice',\n      };\n    }\n\n    // Check total validation\n    if (!data.isValid && data.validationMessage) {\n      warnings.push(data.validationMessage);\n    }\n\n    // Check for unreasonable amounts\n    const highAmountEntries = [...data.entries, ...data.pickupServices, ...data.extraDrops]\n      .filter(entry => entry.amount > 500);\n    \n    if (highAmountEntries.length > 0) {\n      warnings.push(`${highAmountEntries.length} entries with amounts over £500 detected`);\n    }\n\n    // Check for zero amounts\n    const zeroAmountEntries = [...data.entries, ...data.pickupServices, ...data.extraDrops]\n      .filter(entry => entry.amount === 0);\n    \n    if (zeroAmountEntries.length > 0) {\n      warnings.push(`${zeroAmountEntries.length} entries with zero amounts detected`);\n    }\n\n    return {\n      isValid: true,\n      warnings,\n    };\n  }\n\n  protected checkContentPatterns(content: string): boolean {\n    const invoiceIndicators = [\n      'invoice',\n      'docket total',\n      'gbp',\n      'total:',\n      '£',\n    ];\n\n    const lowerContent = content.toLowerCase();\n    return invoiceIndicators.some(indicator => lowerContent.includes(indicator));\n  }\n\n  /**\n   * Extract document total from invoice (based on original system patterns)\n   */\n  private extractDocumentTotal(text: string): number | null {\n    // Pattern 1: \"Docket Total: £X.XX\"\n    const docketTotalPattern = /docket\\s+total:\\s*£(\\d+(?:,\\d{3})*\\.?\\d{0,2})/i;\n    let match = text.match(docketTotalPattern);\n    \n    if (match) {\n      return this.parseInvoiceAmount(match[1]);\n    }\n\n    // Pattern 2: \"Total: GBP £X.XX\"\n    const gbpTotalPattern = /total:\\s*gbp\\s*£(\\d+(?:,\\d{3})*\\.?\\d{0,2})/i;\n    match = text.match(gbpTotalPattern);\n    \n    if (match) {\n      return this.parseInvoiceAmount(match[1]);\n    }\n\n    // Pattern 3: \"GBP £X.XX Total:\"\n    const gbpTotalPattern2 = /gbp\\s*£(\\d+(?:,\\d{3})*\\.?\\d{0,2})\\s*total:/i;\n    match = text.match(gbpTotalPattern2);\n    \n    if (match) {\n      return this.parseInvoiceAmount(match[1]);\n    }\n\n    return null;\n  }\n\n  /**\n   * Extract invoice amounts using token-based approach - exact copy from original extractInvoiceAmounts  \n   */\n  private extractEntries(text: string): InvoiceEntry[] {\n    const entries: InvoiceEntry[] = [];\n    \n    const tokens = text.split(/\\s+/);\n    let currentDate: string | null = null;\n    let currentTime: string | null = null;\n    \n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      \n      // Stop at Docket Total marker - exact same logic as original\n      if (token === 'Docket' && i + 1 < tokens.length && tokens[i+1] === 'Total:') {\n        break;\n      }\n      \n      // Look for date patterns DD/MM/YY\n      if (/^\\d{2}\\/\\d{2}\\/\\d{2}$/.test(token)) {\n        if (i + 1 < tokens.length && /^\\d{2}:\\d{2}$/.test(tokens[i + 1])) {\n          \n          const [day, month, year] = token.split('/');\n          currentDate = `20${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n          currentTime = tokens[i + 1];\n          \n          const isPickup = i + 2 < tokens.length && tokens[i + 2] === '-PickUp';\n          \n          // Look for amount in next 30 tokens\n          let foundAmount = false;\n          for (let j = i + 2; j < Math.min(i + 30, tokens.length); j++) {\n            const checkToken = tokens[j];\n            \n            if (/^\\d+\\.\\d+/.test(checkToken)) {\n              const match = checkToken.match(/^(\\d+\\.\\d{2})/);\n              if (match) {\n                const amount = parseFloat(match[1]);\n                \n                // Apply original validation: amounts between £3.00 and £500.00\n                if (amount >= 3.00 && amount <= 500.00) {\n                  const dateParts = currentDate.split('-');\n                  const date = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));\n                  \n                  entries.push({\n                    date,\n                    time: currentTime || undefined,\n                    amount,\n                    serviceType: isPickup ? 'Pickup Service' : 'Standard',\n                  });\n                  foundAmount = true;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    return entries;\n  }\n\n  /**\n   * Identify service type from description\n   */\n  private identifyServiceType(description: string): string {\n    const lowerDesc = description.toLowerCase();\n    \n    if (lowerDesc.includes('multidrop')) return 'Multidrop';\n    if (lowerDesc.includes('small van')) return 'Small Van';\n    if (lowerDesc.includes('lwb transit')) return 'LWB Transit';\n    if (lowerDesc.includes('pickup')) return 'Pickup Service';\n    if (lowerDesc.includes('extra drop')) return 'Extra Drop';\n    \n    return 'Standard';\n  }\n\n  /**\n   * Parse amount string to number (invoice-specific implementation)\n   */\n  private parseInvoiceAmount(amountStr: string): number {\n    return parseFloat(amountStr.replace(/,/g, ''));\n  }\n\n  /**\n   * Validate totals match (with tolerance for rounding)\n   */\n  private validateTotals(calculatedTotal: number, documentTotal: number | null): boolean {\n    if (documentTotal === null) return true; // Can't validate without document total\n    \n    const tolerance = 0.01; // £0.01 tolerance\n    return Math.abs(calculatedTotal - documentTotal) <= tolerance;\n  }\n\n  /**\n   * Get validation message for total comparison\n   */\n  private getValidationMessage(calculatedTotal: number, documentTotal: number | null): string | undefined {\n    if (documentTotal === null) {\n      return 'Could not find document total for validation';\n    }\n    \n    const difference = calculatedTotal - documentTotal;\n    \n    if (Math.abs(difference) <= 0.01) {\n      return 'Totals match - validation successful';\n    }\n    \n    return `Total mismatch: calculated £${calculatedTotal.toFixed(2)}, document shows £${documentTotal.toFixed(2)} (difference: £${difference.toFixed(2)})`;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/infrastructure/pdf/pdf-parser-base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/infrastructure/pdf/pdf-processor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lowerName' is assigned a value but never used.","line":214,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":214,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lowerContent' is assigned a value but never used.","line":215,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":215,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * PDF Processor\n * Orchestrates PDF parsing using the appropriate parser based on file content\n */\n\nimport { RunsheetParser, RunsheetData } from './runsheet-parser';\nimport { InvoiceParser, InvoiceData } from './invoice-parser';\nimport type { PDFParseResult } from '../../../types/core';\nimport { generateUUID } from '@/lib/utils';\nimport { fileValidationService, FileMetadata } from '@/lib/domain/services/file-validation-service';\nimport type { PDFTextContentItem, StringKeyObject } from '@/types/core';\n\nexport interface ProcessedFile {\n  id: string;\n  file: File;\n  type: 'runsheet' | 'invoice' | 'unknown';\n  parseResult: PDFParseResult<RunsheetData | InvoiceData>;\n  hash: string;\n  transformedData?: StringKeyObject; // Optional transformed data for service compatibility\n}\n\nexport interface ProcessingResult {\n  files: ProcessedFile[];\n  runsheets: Array<ProcessedFile & { parseResult: PDFParseResult<RunsheetData> }>;\n  invoices: Array<ProcessedFile & { parseResult: PDFParseResult<InvoiceData> }>;\n  errors: Array<{\n    file: File;\n    error: string;\n  }>;\n  summary: {\n    totalFiles: number;\n    successfulFiles: number;\n    failedFiles: number;\n    runsheetCount: number;\n    invoiceCount: number;\n    unknownCount: number;\n  };\n  validation?: {\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n    isUpdated?: boolean;\n    existingAnalysis?: string;\n  };\n  fileMetadata?: FileMetadata[];\n}\n\nexport class PDFProcessor {\n  private runsheetParser = new RunsheetParser();\n  private invoiceParser = new InvoiceParser();\n\n  /**\n   * Process multiple PDF files\n   */\n  async processFiles(files: File[]): Promise<ProcessingResult> {\n    // Run comprehensive file validation first\n    const validation = await fileValidationService.validateFiles(files, {\n      maxFileSize: 50 * 1024 * 1024, // 50MB\n      allowedTypes: ['application/pdf'],\n      checkForUpdates: true,\n      checkForDuplicates: true,\n    });\n\n    // Extract file metadata for storage\n    const fileMetadata: FileMetadata[] = files.map(file => ({\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      lastModified: file.lastModified,\n    }));\n\n    // Check for existing analysis\n    const existingAnalysisId = fileValidationService.findExistingAnalysis(files);\n    if (existingAnalysisId) {\n      validation.existingAnalysis = existingAnalysisId;\n      validation.warnings.push(`Files match existing analysis: ${existingAnalysisId}`);\n    }\n\n    const processedFiles: ProcessedFile[] = [];\n    const errors: ProcessingResult['errors'] = [];\n\n    // Only process if validation passes or user wants to continue with warnings\n    if (validation.isValid || validation.errors.length === 0) {\n      // Process each file\n      for (const file of files) {\n        try {\n          const processed = await this.processFile(file);\n          processedFiles.push(processed);\n        } catch (error) {\n          errors.push({\n            file,\n            error: error instanceof Error ? error.message : 'Unknown error',\n          });\n        }\n      }\n    } else {\n      // Add validation errors to processing errors\n      validation.errors.forEach(error => {\n        errors.push({\n          file: files[0], // Associate with first file for simplicity\n          error,\n        });\n      });\n    }\n\n    // Categorize files\n    const runsheets = processedFiles.filter(\n      (file): file is ProcessedFile & { parseResult: PDFParseResult<RunsheetData> } =>\n        file.type === 'runsheet'\n    );\n\n    const invoices = processedFiles.filter(\n      (file): file is ProcessedFile & { parseResult: PDFParseResult<InvoiceData> } =>\n        file.type === 'invoice'\n    );\n\n    const summary = {\n      totalFiles: files.length,\n      successfulFiles: processedFiles.filter(f => f.parseResult.success).length,\n      failedFiles: processedFiles.filter(f => !f.parseResult.success).length + errors.length,\n      runsheetCount: runsheets.length,\n      invoiceCount: invoices.length,\n      unknownCount: processedFiles.filter(f => f.type === 'unknown').length,\n    };\n\n    return {\n      files: processedFiles,\n      runsheets,\n      invoices,\n      errors,\n      summary,\n      validation: {\n        isValid: validation.isValid,\n        errors: validation.errors,\n        warnings: validation.warnings,\n        isUpdated: validation.isUpdated,\n        existingAnalysis: validation.existingAnalysis,\n      },\n      fileMetadata,\n    };\n  }\n\n  /**\n   * Process a single PDF file\n   */\n  async processFile(file: File): Promise<ProcessedFile> {\n    // Validate file type\n    if (file.type !== 'application/pdf') {\n      throw new Error(`Invalid file type: ${file.type}. Only PDF files are supported.`);\n    }\n\n    // Generate file ID and hash\n    const id = generateUUID();\n    const hash = await this.generateFileHash(file);\n\n    // Get a preview of the file content for parser selection\n    const preview = await this.getFileContentPreview(file);\n\n    // Determine file type and select parser\n    const fileType = this.determineFileType(file.name, preview);\n\n    let parseResult: PDFParseResult<RunsheetData | InvoiceData>;\n\n    switch (fileType) {\n      case 'runsheet':\n        parseResult = await this.runsheetParser.parse(file);\n        break;\n      case 'invoice':\n        parseResult = await this.invoiceParser.parse(file);\n        break;\n      default:\n        // Try both parsers to see which one works better\n        const runsheetResult = await this.runsheetParser.parse(file);\n        const invoiceResult = await this.invoiceParser.parse(file);\n\n        if (runsheetResult.success && !invoiceResult.success) {\n          parseResult = runsheetResult;\n        } else if (invoiceResult.success && !runsheetResult.success) {\n          parseResult = invoiceResult;\n        } else if (runsheetResult.success && invoiceResult.success) {\n          // Both succeeded, choose based on content quality\n          parseResult = this.chooseBetterResult(runsheetResult, invoiceResult);\n        } else {\n          // Both failed, return the runsheet result as default\n          parseResult = runsheetResult;\n        }\n        break;\n    }\n\n    // Generate transformed data for service compatibility if parsing was successful\n    let transformedData: StringKeyObject | undefined;\n    if (parseResult.success && parseResult.data) {\n      if (this.isRunsheetData(parseResult.data)) {\n        transformedData = this.transformRunsheetData(parseResult.data);\n      } else if (this.isInvoiceData(parseResult.data)) {\n        transformedData = this.transformInvoiceData(parseResult.data);\n      }\n    }\n\n    return {\n      id,\n      file,\n      type: fileType,\n      parseResult,\n      hash,\n      transformedData,\n    };\n  }\n\n  /**\n   * Determine file type based on name and content\n   */\n  private determineFileType(fileName: string, content: string): 'runsheet' | 'invoice' | 'unknown' {\n    const lowerName = fileName.toLowerCase();\n    const lowerContent = content.toLowerCase();\n\n    // Check for runsheet indicators\n    if (this.runsheetParser.canParse(fileName, content)) {\n      return 'runsheet';\n    }\n\n    // Check for invoice indicators\n    if (this.invoiceParser.canParse(fileName, content)) {\n      return 'invoice';\n    }\n\n    return 'unknown';\n  }\n\n  /**\n   * Get a preview of file content for parser selection\n   */\n  private async getFileContentPreview(file: File): Promise<string> {\n    try {\n      // Check if PDF.js is available\n      if (typeof window !== 'undefined' && window.pdfjsLib) {\n        // Parse first page to get content preview\n        const arrayBuffer = await file.arrayBuffer();\n        const pdf = await window.pdfjsLib.getDocument(arrayBuffer).promise;\n        \n        if (pdf.numPages > 0) {\n          const page = await pdf.getPage(1);\n          const textContent = await page.getTextContent();\n          const pageText = textContent.items\n            .map((item: PDFTextContentItem) => item.str)\n            .join(' ')\n            .substring(0, 1000); // First 1000 characters for preview\n          \n          return pageText;\n        }\n      }\n      \n      // Fallback to filename-based detection\n      return file.name;\n    } catch (error) {\n      console.warn('PDF content preview failed, falling back to filename:', error);\n      return file.name;\n    }\n  }\n\n  /**\n   * Generate SHA-256 hash for file\n   */\n  private async generateFileHash(file: File): Promise<string> {\n    const buffer = await file.arrayBuffer();\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Choose the better result between two successful parses\n   */\n  private chooseBetterResult(\n    runsheetResult: PDFParseResult<RunsheetData>,\n    invoiceResult: PDFParseResult<InvoiceData>\n  ): PDFParseResult<RunsheetData | InvoiceData> {\n    // Simple heuristic: choose the one with more extracted data\n    const runsheetDataPoints = runsheetResult.data?.totalConsignments || 0;\n    const invoiceDataPoints = invoiceResult.data?.entries.length || 0;\n\n    return runsheetDataPoints >= invoiceDataPoints ? runsheetResult : invoiceResult;\n  }\n\n  /**\n   * Type guard to check if data is RunsheetData\n   */\n  private isRunsheetData(data: unknown): data is RunsheetData {\n    return (\n      typeof data === 'object' &&\n      data !== null &&\n      'consignmentsByDate' in data &&\n      'totalConsignments' in data &&\n      'dates' in data &&\n      'details' in data\n    );\n  }\n\n  /**\n   * Type guard to check if data is InvoiceData\n   */\n  private isInvoiceData(data: unknown): data is InvoiceData {\n    return (\n      typeof data === 'object' &&\n      data !== null &&\n      'entries' in data &&\n      'totalAmount' in data &&\n      'isValid' in data &&\n      'dates' in data\n    );\n  }\n\n  /**\n   * Validate file set - provides warnings but allows analysis with partial data (matching original system)\n   */\n  validateFileSet(result: ProcessingResult): {\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n  } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Check for file types - both runsheets and invoices are optional\n    if (result.runsheets.length === 0 && result.invoices.length === 0 && result.summary.totalFiles > 0) {\n      // Only error if files were uploaded but none could be parsed\n      errors.push('No valid runsheet or invoice files could be processed. Please check your file formats.');\n    }\n\n    // Provide warnings for missing file types\n    if (result.runsheets.length === 0) {\n      warnings.push('No runsheet files found. Consignment counts will need to be entered manually.');\n    }\n\n    if (result.invoices.length === 0) {\n      warnings.push('No invoice files found. Paid amounts will default to £0.00 for payment reconciliation.');\n    }\n\n    // Check for parsing failures\n    const failedRunsheets = result.runsheets.filter(r => !r.parseResult.success);\n    if (failedRunsheets.length > 0) {\n      warnings.push(`${failedRunsheets.length} runsheet(s) failed to parse correctly.`);\n    }\n\n    const failedInvoices = result.invoices.filter(i => !i.parseResult.success);\n    if (failedInvoices.length > 0) {\n      warnings.push(`${failedInvoices.length} invoice(s) failed to parse correctly.`);\n    }\n\n    // Check for unknown file types\n    if (result.summary.unknownCount > 0) {\n      warnings.push(`${result.summary.unknownCount} file(s) could not be classified.`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * Transform runsheet data to match service expectations\n   */\n  transformRunsheetData(data: RunsheetData): StringKeyObject {\n    // Convert Map to plain object for service compatibility\n    const consignments: Record<string, number> = {};\n    for (const [dateStr, count] of data.consignmentsByDate) {\n      // Convert to YYYY-MM-DD format for consistency\n      const date = new Date(dateStr);\n      const isoDate = date.toISOString().split('T')[0];\n      consignments[isoDate] = count;\n    }\n\n    return {\n      type: 'runsheet',\n      consignments,\n      totalConsignments: data.totalConsignments,\n      dates: data.dates,\n      details: data.details,\n    };\n  }\n\n  /**\n   * Transform invoice data to match service expectations\n   */\n  transformInvoiceData(data: InvoiceData): StringKeyObject {\n    // Convert entries to the format expected by service\n    const payments = data.entries.map(entry => ({\n      date: entry.date,\n      time: entry.time,\n      amount: entry.amount,\n      serviceType: entry.serviceType,\n      description: entry.description,\n    }));\n\n    return {\n      type: 'invoice',\n      payments,\n      totalAmount: data.totalAmount,\n      documentTotal: data.documentTotal,\n      isValid: data.isValid,\n      dates: data.dates,\n      pickupServices: data.pickupServices,\n      extraDrops: data.extraDrops,\n      validationMessage: data.validationMessage,\n    };\n  }\n\n  /**\n   * Process runsheet from ArrayBuffer (for API routes)\n   */\n  async processRunsheet(arrayBuffer: ArrayBuffer, fileName: string): Promise<StringKeyObject> {\n    // Create a File object from ArrayBuffer\n    const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n    const file = new File([blob], fileName, { type: 'application/pdf' });\n    \n    // Use existing runsheet parser\n    const parseResult = await this.runsheetParser.parse(file);\n    \n    if (parseResult.success && parseResult.data) {\n      return this.transformRunsheetData(parseResult.data);\n    } else {\n      throw new Error(parseResult.error || 'Failed to process runsheet');\n    }\n  }\n\n  /**\n   * Process invoice from ArrayBuffer (for API routes)\n   */\n  async processInvoice(arrayBuffer: ArrayBuffer, fileName: string): Promise<StringKeyObject> {\n    // Create a File object from ArrayBuffer\n    const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n    const file = new File([blob], fileName, { type: 'application/pdf' });\n    \n    // Use existing invoice parser\n    const parseResult = await this.invoiceParser.parse(file);\n    \n    if (parseResult.success && parseResult.data) {\n      return this.transformInvoiceData(parseResult.data);\n    } else {\n      throw new Error(parseResult.error || 'Failed to process invoice');\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/infrastructure/pdf/runsheet-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":200,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Runsheet PDF Parser\n * Extracts consignment counts from delivery runsheets\n * Based on the original system's parsing logic\n */\n\nimport { PDFParserBase } from './pdf-parser-base';\nimport type { ParsedPDFData } from '../../../types/core';\n\nexport interface RunsheetData {\n  dates: Date[];\n  consignmentsByDate: Map<string, number>; // date string -> consignment count\n  totalConsignments: number;\n  details: Array<{\n    date: Date;\n    consignments: number;\n    consignmentNumbers: string[];\n  }>;\n}\n\nexport class RunsheetParser extends PDFParserBase<RunsheetData> {\n  protected fileTypeIdentifiers = ['runsheet', 'dv_'];\n\n  protected async extractData(rawData: ParsedPDFData, filename?: string): Promise<RunsheetData> {\n    const dates: Date[] = [];\n    const consignmentsByDate = new Map<string, number>();\n    const details: RunsheetData['details'] = [];\n    \n    // Process each page\n    for (const page of rawData.pages) {\n      const pageData = this.extractPageData(page.text);\n      \n      if (pageData.consignments.length > 0) {\n        let dateToUse = pageData.date;\n        \n        // If no date found, try to infer from filename or use current date as fallback\n        if (!dateToUse) {\n          // Try to extract date from filename (e.g., \"runsheetDV_2025-07-01.pdf\")\n          const filenameMatch = filename?.match(/(\\d{4}[-\\/]\\d{2}[-\\/]\\d{2})/);\n          if (filenameMatch) {\n            const parts = filenameMatch[1].replace(/\\//g, '-').split('-');\n            dateToUse = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));\n          } else {\n            // As a last resort, use current date (this matches original behavior)\n            dateToUse = new Date();\n          }\n        }\n        \n        const dateKey = dateToUse.toISOString().split('T')[0]; // Use ISO format like original\n        const consignmentCount = pageData.consignments.length;\n        \n        dates.push(dateToUse);\n        consignmentsByDate.set(dateKey, consignmentCount);\n        \n        details.push({\n          date: dateToUse,\n          consignments: consignmentCount,\n          consignmentNumbers: pageData.consignments,\n        });\n      }\n    }\n\n    // Remove duplicate dates and sort\n    const uniqueDates = dates.filter(\n      (date, index, self) => self.findIndex(d => d.getTime() === date.getTime()) === index\n    );\n    uniqueDates.sort((a, b) => a.getTime() - b.getTime());\n\n    const totalConsignments = Array.from(consignmentsByDate.values())\n      .reduce((sum, count) => sum + count, 0);\n\n    const sortedDetails = details.toSorted((a, b) => a.date.getTime() - b.date.getTime());\n\n    return {\n      dates: uniqueDates,\n      consignmentsByDate,\n      totalConsignments,\n      details: sortedDetails,\n    };\n  }\n\n  protected async validateData(data: RunsheetData): Promise<{\n    isValid: boolean;\n    error?: string;\n    warnings?: string[];\n  }> {\n    const warnings: string[] = [];\n\n    // Check if any data was extracted\n    if (data.dates.length === 0) {\n      return {\n        isValid: false,\n        error: 'No dates found in runsheet',\n      };\n    }\n\n    if (data.totalConsignments === 0) {\n      return {\n        isValid: false,\n        error: 'No consignments found in runsheet',\n      };\n    }\n\n    // Check for reasonable consignment counts\n    for (const [dateStr, count] of data.consignmentsByDate) {\n      if (count > 200) {\n        warnings.push(`Very high consignment count (${count}) on ${dateStr}`);\n      }\n    }\n\n    // Check for Sunday deliveries (unusual but possible)\n    const sundayDeliveries = data.dates.filter(date => date.getDay() === 0);\n    if (sundayDeliveries.length > 0) {\n      warnings.push('Sunday deliveries detected');\n    }\n\n    return {\n      isValid: true,\n      warnings,\n    };\n  }\n\n  protected checkContentPatterns(content: string): boolean {\n    const runsheetIndicators = [\n      'runsheet',\n      'delivery',\n      'collection',\n      'consignment',\n      'dv_', // From filename patterns\n    ];\n\n    const lowerContent = content.toLowerCase();\n    return runsheetIndicators.some(indicator => lowerContent.includes(indicator));\n  }\n\n  /**\n   * Extract data from a single page of the runsheet\n   */\n  private extractPageData(pageText: string): {\n    date: Date | null;\n    consignments: string[];\n  } {\n    // Extract date using patterns from original system\n    const date = this.extractDateFromPage(pageText);\n    \n    // Extract consignments using patterns from original system  \n    const consignments = this.extractConsignmentsFromPage(pageText);\n    \n    return { date, consignments };\n  }\n\n  /**\n   * Extract date from runsheet text - exact copy from original extractDateFromRunsheet\n   */\n  private extractDateFromPage(text: string): Date | null {\n    const datePattern = /Date:\\s*(\\d{2}[-/]\\d{2}[-/]\\d{4})/;\n    const match = datePattern.exec(text);\n    \n    if (match) {\n      const parts = match[1].replace(/\\//g, '-').split('-');\n      const day = parseInt(parts[0]);\n      const month = parseInt(parts[1]) - 1; // Month is 0-indexed\n      const year = parseInt(parts[2]);\n      return new Date(year, month, day);\n    }\n    \n    // Try alternative date patterns that might be in the PDF\n    const altPatterns = [\n      /(\\d{2}[-/]\\d{2}[-/]\\d{4})/,  // Any DD/MM/YYYY or DD-MM-YYYY\n      /(\\d{4}[-/]\\d{2}[-/]\\d{2})/,  // YYYY/MM/DD or YYYY-MM-DD\n      /Date[\\s:]*(\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4})/i, // Flexible Date: pattern\n    ];\n    \n    for (const pattern of altPatterns) {\n      const altMatch = pattern.exec(text);\n      if (altMatch) {\n        try {\n          const dateStr = altMatch[1];\n          const parts = dateStr.replace(/\\//g, '-').split('-');\n          \n          let day, month, year;\n          if (parts[0].length === 4) {\n            // YYYY-MM-DD format\n            year = parseInt(parts[0]);\n            month = parseInt(parts[1]) - 1;\n            day = parseInt(parts[2]);\n          } else {\n            // DD-MM-YYYY format\n            day = parseInt(parts[0]);\n            month = parseInt(parts[1]) - 1;\n            year = parseInt(parts[2]);\n            \n            // Handle 2-digit years\n            if (year < 100) {\n              year += year < 50 ? 2000 : 1900;\n            }\n          }\n          \n          return new Date(year, month, day);\n        } catch (e) {\n          // Continue to next pattern\n        }\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Extract consignment count using token-based approach - exact copy from original extractConsignmentsFromRunsheet\n   */\n  private extractConsignmentsFromPage(text: string): string[] {\n    const tokens = text.split(/\\s+/);\n    const consignmentsList = [];\n    \n    for (let i = 0; i < tokens.length - 1; i++) {\n      const token = tokens[i];\n      const nextToken = tokens[i + 1];\n      \n      if (/^\\d+$/.test(token)) {\n        const num = parseInt(token);\n        \n        if (/^\\d{7}$/.test(nextToken) || /^AH\\d+$/.test(nextToken)) {\n          const nearbyTokens = tokens.slice(i, i + 10).join(' ');\n          \n          if (nearbyTokens.includes('Delivery') || nearbyTokens.includes('Collection')) {\n            consignmentsList.push({\n              number: num,\n              id: nextToken\n            });\n          }\n        }\n      }\n    }\n    \n    // Return just the IDs as strings to match interface\n    return consignmentsList.map(c => c.id);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/middleware/auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used.","line":26,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { createClient as createServerClient } from '@/lib/supabase/server';\nimport { AppError, ErrorCodes, Result } from '@/lib/utils/errors';\nimport { z } from 'zod';\n\nexport interface AuthenticatedUser {\n  id: string;\n  email: string;\n  role?: string;\n  emailVerified: boolean;\n}\n\nexport interface AuthContext {\n  user: AuthenticatedUser;\n  supabase: Awaited<ReturnType<typeof createServerClient>>;\n}\n\nexport interface RouteContext {\n  params?: Record<string, string | string[]>;\n  [key: string]: unknown;\n}\n\n/**\n * Enhanced authentication middleware with comprehensive error handling\n */\nexport async function authenticateApiRequest(request: NextRequest): Promise<Result<AuthContext>> {\n  try {\n    const supabase = await createServerClient();\n    \n    // Get user with proper error handling\n    const { data: { user }, error: authError } = await supabase.auth.getUser();\n    \n    if (authError) {\n      return Result.failure(\n        new AppError(\n          'Authentication failed',\n          ErrorCodes.AUTH_INVALID_CREDENTIALS,\n          401,\n          true,\n          { originalError: authError.message }\n        )\n      );\n    }\n    \n    if (!user) {\n      return Result.failure(\n        new AppError(\n          'No authenticated user found',\n          ErrorCodes.AUTH_UNAUTHORIZED,\n          401\n        )\n      );\n    }\n\n    // Validate user session\n    if (!user.email_confirmed_at) {\n      return Result.failure(\n        new AppError(\n          'Email not verified',\n          ErrorCodes.AUTH_EMAIL_NOT_VERIFIED,\n          401,\n          true,\n          { userId: user.id }\n        )\n      );\n    }\n\n    const authenticatedUser: AuthenticatedUser = {\n      id: user.id,\n      email: user.email || '',\n      role: user.user_metadata?.role,\n      emailVerified: !!user.email_confirmed_at,\n    };\n\n    return Result.success({\n      user: authenticatedUser,\n      supabase,\n    });\n\n  } catch (error) {\n    return Result.failure(\n      new AppError(\n        'Authentication system error',\n        ErrorCodes.AUTH_UNAUTHORIZED,\n        500,\n        false,\n        { originalError: error instanceof Error ? error.message : 'Unknown error' }\n      )\n    );\n  }\n}\n\n// Rate limiting configuration\ninterface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  skipSuccessfulRequests?: boolean;\n}\n\nconst rateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\n/**\n * Enhanced rate limiting with proper error handling\n */\nexport async function checkRateLimit(\n  request: NextRequest,\n  userId: string,\n  config: RateLimitConfig = {\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    maxRequests: 100,\n  }\n): Promise<Result<void>> {\n  try {\n    const key = `${userId}:${request.nextUrl.pathname}`;\n    const now = Date.now();\n    \n    // Clean up old entries\n    for (const [k, v] of rateLimitStore.entries()) {\n      if (v.resetTime < now) {\n        rateLimitStore.delete(k);\n      }\n    }\n    \n    const current = rateLimitStore.get(key);\n    \n    if (!current) {\n      rateLimitStore.set(key, { count: 1, resetTime: now + config.windowMs });\n      return Result.success(undefined);\n    }\n    \n    if (current.resetTime < now) {\n      rateLimitStore.set(key, { count: 1, resetTime: now + config.windowMs });\n      return Result.success(undefined);\n    }\n    \n    if (current.count >= config.maxRequests) {\n      return Result.failure(\n        new AppError(\n          'Rate limit exceeded',\n          ErrorCodes.RATE_LIMIT_EXCEEDED,\n          429,\n          true,\n          {\n            limit: config.maxRequests,\n            windowMs: config.windowMs,\n            resetTime: current.resetTime,\n          }\n        )\n      );\n    }\n    \n    current.count++;\n    return Result.success(undefined);\n\n  } catch (error) {\n    // Rate limiting failure shouldn't block requests\n    console.error('Rate limiting error:', error);\n    return Result.success(undefined);\n  }\n}\n\n/**\n * Create standardized error responses\n */\nfunction createErrorResponse(error: AppError): NextResponse {\n  const response = {\n    success: false,\n    error: {\n      message: error.message,\n      code: error.code,\n      ...(error.context && { context: error.context }),\n    },\n    timestamp: new Date().toISOString(),\n  };\n\n  // Don't expose internal error details in production\n  if (process.env.NODE_ENV === 'production' && !error.isOperational) {\n    response.error.message = 'Internal server error';\n    delete response.error.context;\n  }\n\n  return NextResponse.json(response, {\n    status: error.statusCode,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}\n\n/**\n * Enhanced API wrapper with comprehensive error handling\n */\nexport function withAuth<T extends RouteContext = RouteContext>(\n  handler: (request: NextRequest, context: T, auth: AuthContext) => Promise<NextResponse>\n) {\n  return async (request: NextRequest, context: T) => {\n    try {\n      // Authenticate request\n      const authResult = await authenticateApiRequest(request);\n      if (authResult.isFailure) {\n        return createErrorResponse(authResult.error);\n      }\n\n      // Rate limiting\n      const rateLimitResult = await checkRateLimit(request, authResult.data.user.id);\n      if (rateLimitResult.isFailure) {\n        return createErrorResponse(rateLimitResult.error);\n      }\n\n      // Call the actual handler\n      return await handler(request, context, authResult.data);\n      \n    } catch (error) {\n      console.error('API Error:', error);\n      \n      const appError = error instanceof AppError\n        ? error\n        : new AppError(\n            'Internal server error',\n            ErrorCodes.INTERNAL_ERROR,\n            500,\n            false,\n            { originalError: error instanceof Error ? error.message : 'Unknown error' }\n          );\n      \n      return createErrorResponse(appError);\n    }\n  };\n}\n\n/**\n * Input validation middleware\n */\nexport function withValidation<T>(schema: z.ZodSchema<T>) {\n  return function(\n    handler: (request: NextRequest, validatedData: T, context: RouteContext, auth: AuthContext) => Promise<NextResponse>\n  ) {\n    return withAuth(async (request, context, auth) => {\n      try {\n        const body = await request.json();\n        const validationResult = schema.safeParse(body);\n        \n        if (!validationResult.success) {\n          const error = new AppError(\n            'Validation failed',\n            ErrorCodes.VALIDATION_INVALID_FORMAT,\n            400,\n            true,\n            {\n              validationErrors: validationResult.error.issues,\n            }\n          );\n          return createErrorResponse(error);\n        }\n\n        return await handler(request, validationResult.data, context, auth);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          const appError = new AppError(\n            'Invalid JSON in request body',\n            ErrorCodes.VALIDATION_INVALID_FORMAT,\n            400\n          );\n          return createErrorResponse(appError);\n        }\n        throw error;\n      }\n    });\n  };\n}\n\n/**\n * CORS headers for API responses\n */\nexport function addCorsHeaders(response: NextResponse): NextResponse {\n  response.headers.set('Access-Control-Allow-Origin', process.env.ALLOWED_ORIGINS || '*');\n  response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS');\n  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, x-api-key');\n  response.headers.set('Access-Control-Max-Age', '86400');\n  response.headers.set('Access-Control-Allow-Credentials', 'true');\n  return response;\n}\n\n/**\n * Handle OPTIONS requests for CORS\n */\nexport function handleOptions(): NextResponse {\n  const response = new NextResponse(null, { status: 200 });\n  return addCorsHeaders(response);\n}\n\n/**\n * API Key authentication (for future external API access)\n */\nexport async function authenticateApiKey(request: NextRequest): Promise<Result<{\n  userId: string;\n  keyName: string;\n}>> {\n  const apiKey = request.headers.get('x-api-key') || request.headers.get('authorization')?.replace('Bearer ', '');\n  \n  if (!apiKey) {\n    return Result.failure(\n      new AppError(\n        'API key required',\n        ErrorCodes.AUTH_UNAUTHORIZED,\n        401,\n        true,\n        { message: 'Provide API key in x-api-key header or Authorization header' }\n      )\n    );\n  }\n\n  // In production, this would validate against a database of API keys\n  return Result.failure(\n    new AppError(\n      'API key authentication not implemented',\n      ErrorCodes.AUTH_UNAUTHORIZED,\n      501,\n      true,\n      { message: 'Use session-based authentication' }\n    )\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/optimization/dynamic-charts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/optimization/dynamic-motion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/optimization/lazyLibraries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/providers/auth-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/repositories/analysis-repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/analysis-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AnalysisFileRecord' is defined but never used.","line":16,"column":61,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":79},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ParsedFileData' is defined but never used.","line":26,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used.","line":672,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":672,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Analysis, type AnalysisSource } from '@/lib/domain/entities/analysis';\nimport type { RunsheetData } from '@/lib/infrastructure/pdf/runsheet-parser';\nimport type { InvoiceData, InvoiceEntry } from '@/lib/infrastructure/pdf/invoice-parser';\n\n// Union type for parsed PDF data\nexport type ParsedPDFDataTypes = (RunsheetData & { type: 'runsheet' }) | (InvoiceData & { type: 'invoice' });\n\n// Payment object interface for validation\ninterface PaymentObject {\n  date: string | number | Date;\n  amount: number | string;\n}\nimport { PaymentRules } from '@/lib/domain/entities/payment-rules';\nimport { DailyEntry } from '@/lib/domain/entities/daily-entry';\nimport { FileFingerprintService } from '@/lib/domain/services/file-fingerprint-service';\nimport { analysisRepository, type AnalysisWithDetails, type AnalysisFileRecord } from '@/lib/repositories/analysis-repository';\n// Dynamic import for PDF processor to avoid SSR issues\nconst loadPDFProcessor = async () => {\n  const { PDFProcessor } = await import('@/lib/infrastructure/pdf/pdf-processor');\n  return PDFProcessor;\n};\nimport { DEFAULT_PAYMENT_RULES, type FileType } from '@/lib/constants';\nimport { type StringKeyObject } from '@/types/core';\n\n// Type for parsed PDF data\ntype ParsedFileData = RunsheetData | InvoiceData;\n\n// Interface for file records - matches CreateAnalysisFileData\ninterface FileRecord {\n  storage_path: string;\n  original_name: string;\n  file_size: number;\n  file_hash: string;\n  mime_type: string;\n  file_type: FileType;\n  parsed_data?: StringKeyObject;\n}\n\n\nexport interface AnalysisFile {\n  file: File;\n  name: string;\n  size: number;\n  type: string;\n  lastModified: number;\n}\n\nexport interface CreateAnalysisRequest {\n  userId: string;\n  files?: AnalysisFile[];\n  manualEntries?: {\n    date: string;\n    consignments: number;\n    paid: number;\n    hasUnloadingBonus?: boolean;\n    hasAttendanceBonus?: boolean;\n    hasEarlyBonus?: boolean;\n    pickups?: number;\n  }[];\n  paymentRules?: Partial<{\n    weekdayRate: number;\n    saturdayRate: number;\n    unloadingBonus: number;\n    attendanceBonus: number;\n    earlyBonus: number;\n  }>;\n  metadata?: {\n    description?: string;\n    notes?: string;\n  };\n}\n\nexport interface AnalysisProgress {\n  stage: 'initializing' | 'processing_files' | 'calculating' | 'saving' | 'completed' | 'error';\n  progress: number; // 0-100\n  message: string;\n  currentFile?: string;\n  totalFiles?: number;\n  processedFiles?: number;\n  error?: string;\n}\n\nexport interface AnalysisResult {\n  analysisId: string;\n  analysis: Analysis;\n  success: boolean;\n  error?: string;\n}\n\nexport class AnalysisService {\n  private readonly fingerprintService = new FileFingerprintService();\n  \n  private async getPDFProcessor() {\n    const PDFProcessorClass = await loadPDFProcessor();\n    return new PDFProcessorClass();\n  }\n\n  /**\n   * Create and process a new analysis\n   */\n  async createAnalysis(\n    request: CreateAnalysisRequest,\n    onProgress?: (progress: AnalysisProgress) => void\n  ): Promise<AnalysisResult> {\n    try {\n      onProgress?.({\n        stage: 'initializing',\n        progress: 0,\n        message: 'Initializing analysis...',\n      });\n\n      // Validate request\n      if (!request.files?.length && !request.manualEntries?.length) {\n        throw new Error('Analysis requires either files or manual entries');\n      }\n\n      // Create payment rules\n      const paymentRules = new PaymentRules({\n        userId: request.userId,\n        ...DEFAULT_PAYMENT_RULES,\n        ...request.paymentRules,\n      });\n\n      // Generate fingerprint for duplicate detection\n      let fingerprint: string | undefined;\n      if (request.files?.length) {\n        const fingerprintResult = await this.fingerprintService.createFingerprint(request.files);\n        fingerprint = fingerprintResult.fingerprint;\n        \n        // Check for duplicate\n        const { data: existingAnalysis } = await analysisRepository.findAnalysisByFingerprint(\n          request.userId,\n          fingerprint\n        );\n        \n        if (existingAnalysis) {\n          throw new Error(`Duplicate analysis detected. Analysis from ${new Date(existingAnalysis.created_at).toLocaleDateString()} already exists.`);\n        }\n      }\n\n      onProgress?.({\n        stage: 'processing_files',\n        progress: 10,\n        message: 'Processing files...',\n        totalFiles: request.files?.length || 0,\n        processedFiles: 0,\n      });\n\n      // Process files if provided\n      let dailyEntries: DailyEntry[] = [];\n      let fileRecords: FileRecord[] = [];\n      \n      if (request.files?.length) {\n        const { entries, files } = await this.processFiles(\n          request.files,\n          paymentRules,\n          (fileProgress) => {\n            onProgress?.({\n              stage: 'processing_files',\n              progress: 10 + (fileProgress.progress * 0.5), // 10-60% for file processing\n              message: `Processing ${fileProgress.currentFile}...`,\n              currentFile: fileProgress.currentFile,\n              totalFiles: fileProgress.totalFiles,\n              processedFiles: fileProgress.processedFiles,\n            });\n          }\n        );\n        dailyEntries = entries;\n        fileRecords = files;\n      }\n\n      // Process manual entries if provided\n      if (request.manualEntries?.length) {\n        onProgress?.({\n          stage: 'processing_files',\n          progress: 60,\n          message: 'Processing manual entries...',\n        });\n\n        const manualDailyEntries = this.processManualEntries(request.manualEntries, paymentRules);\n        dailyEntries = [...dailyEntries, ...manualDailyEntries];\n      }\n\n      onProgress?.({\n        stage: 'calculating',\n        progress: 70,\n        message: 'Calculating payment totals...',\n      });\n\n      // Create analysis entity\n      const analysis = new Analysis({\n        userId: request.userId,\n        fingerprint: fingerprint || '',\n        source: request.files?.length ? 'upload' : 'manual',\n        periodStart: new Date(), // This will be calculated based on entries\n        periodEnd: new Date(),   // This will be calculated based on entries\n        rulesVersion: 1, // Placeholder\n        dailyEntries,\n        metadata: {\n          description: request.metadata?.description,\n          notes: request.metadata?.notes,\n          fileCount: request.files?.length || 0,\n          manualEntryCount: request.manualEntries?.length || 0,\n        },\n      });\n\n      onProgress?.({\n        stage: 'saving',\n        progress: 80,\n        message: 'Saving analysis to database...',\n      });\n\n      // Save to database\n      const analysisId = await this.saveAnalysisToDatabase(analysis, fileRecords);\n\n      onProgress?.({\n        stage: 'completed',\n        progress: 100,\n        message: 'Analysis completed successfully!',\n      });\n\n      return {\n        analysisId,\n        analysis,\n        success: true,\n      };\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      \n      onProgress?.({\n        stage: 'error',\n        progress: 0,\n        message: 'Analysis failed',\n        error: errorMessage,\n      });\n\n      return {\n        analysisId: '',\n        analysis: null as unknown as Analysis,\n        success: false,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Process uploaded files\n   */\n  private async processFiles(\n    files: AnalysisFile[],\n    paymentRules: PaymentRules,\n    onProgress?: (progress: { progress: number; currentFile: string; totalFiles: number; processedFiles: number }) => void\n  ): Promise<{ entries: DailyEntry[]; files: FileRecord[] }> {\n    const dailyEntries: DailyEntry[] = [];\n    const fileRecords: FileRecord[] = [];\n    \n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      \n      onProgress?.({\n        progress: (i / files.length) * 100,\n        currentFile: file.name,\n        totalFiles: files.length,\n        processedFiles: i,\n      });\n\n      try {\n        // Process PDF file\n        const pdfProcessor = await this.getPDFProcessor();\n        const result = await pdfProcessor.processFile(file.file);\n        \n        if (result.parseResult.success && result.parseResult.data) {\n          // Convert processed data to daily entries\n          const entries = this.convertToDailyEntries(result.parseResult.data as ParsedPDFDataTypes, paymentRules);\n          dailyEntries.push(...entries);\n\n          // Create file record\n          fileRecords.push({\n            storage_path: `analyses/${Date.now()}_${file.name}`, // Would upload to storage in production\n            original_name: file.name,\n            file_size: file.size,\n            file_hash: await this.calculateFileHash(file.file),\n            mime_type: file.type,\n            file_type: this.detectFileType(file.name),\n            parsed_data: result.parseResult.data as unknown as StringKeyObject,\n          });\n        } else {\n          console.warn(`Failed to process file ${file.name}:`, result.parseResult.error || 'Unknown error');\n        }\n      } catch (error) {\n        console.error(`Error processing file ${file.name}:`, error);\n      }\n    }\n\n    onProgress?.({\n      progress: 100,\n      currentFile: '',\n      totalFiles: files.length,\n      processedFiles: files.length,\n    });\n\n    return { entries: dailyEntries, files: fileRecords };\n  }\n\n  /**\n   * Process manual entries\n   */\n  private processManualEntries(\n    entries: CreateAnalysisRequest['manualEntries'],\n    paymentRules: PaymentRules\n  ): DailyEntry[] {\n    if (!entries) return [];\n\n    return entries.map(entry => {\n      const date = new Date(entry.date);\n      const dayOfWeek = date.getDay();\n      const rate = paymentRules.getRateForDay(dayOfWeek);\n      const bonuses = paymentRules.getApplicableBonuses(dayOfWeek);\n      \n      return new DailyEntry({\n        analysisId: '', // Will be set later\n        date,\n        consignments: entry.consignments,\n        rate: rate.amount,\n        paidAmount: entry.paid,\n        pickups: entry.pickups || 0,\n        unloadingBonus: entry.hasUnloadingBonus ? bonuses.unloading.amount : 0,\n        attendanceBonus: entry.hasAttendanceBonus ? bonuses.attendance.amount : 0,\n        earlyBonus: entry.hasEarlyBonus ? bonuses.early.amount : 0,\n      });\n    });\n  }\n\n  /**\n   * Convert processed PDF data to daily entries\n   */\n  private convertToDailyEntries(data: ParsedPDFDataTypes, paymentRules: PaymentRules): DailyEntry[] {\n    const entries: DailyEntry[] = [];\n\n    // Handle runsheet data\n    if (data.type === 'runsheet' && data.consignmentsByDate) {\n      const consignmentData = data.consignmentsByDate;\n      const runsheetEntries = this.processRunsheetData(consignmentData, paymentRules);\n      entries.push(...runsheetEntries);\n    }\n\n    // Handle invoice data\n    if (data.type === 'invoice' && Array.isArray(data.entries)) {\n      this.processInvoiceData(data.entries, entries, paymentRules);\n    }\n\n    return entries;\n  }\n\n  /**\n   * Process runsheet data and create daily entries\n   */\n  private processRunsheetData(consignments: Map<string, number> | Record<string, number>, paymentRules: PaymentRules): DailyEntry[] {\n    const entries: DailyEntry[] = [];\n\n    const consignmentEntries = consignments instanceof Map ? Array.from(consignments.entries()) : Object.entries(consignments);\n\n    for (const [dateStr, count] of consignmentEntries) {\n      const date = new Date(dateStr);\n      if (isNaN(date.getTime())) continue;\n\n      const entry = this.createDailyEntryFromRunsheet(date, count, paymentRules);\n      entries.push(entry);\n    }\n\n    return entries;\n  }\n\n  /**\n   * Create daily entry from runsheet data\n   */\n  private createDailyEntryFromRunsheet(date: Date, count: number, paymentRules: PaymentRules): DailyEntry {\n    const dayOfWeek = date.getDay();\n    const rate = paymentRules.getRateForDay(dayOfWeek);\n    const bonuses = paymentRules.getApplicableBonuses(dayOfWeek);\n\n    return new DailyEntry({\n      analysisId: '', // Will be set later\n      date,\n      consignments: count,\n      rate: rate.amount,\n      paidAmount: 0, // Will be calculated\n      pickups: 0,\n      unloadingBonus: bonuses.unloading.amount,\n      attendanceBonus: bonuses.attendance.amount,\n      earlyBonus: bonuses.early.amount,\n    });\n  }\n\n  /**\n   * Process invoice data and update/create daily entries\n   */\n  private processInvoiceData(payments: InvoiceEntry[], entries: DailyEntry[], paymentRules: PaymentRules, mergeStrategy: 'add' | 'replace' | 'max' | 'smart' = 'add'): void {\n    for (const payment of payments) {\n      if (!payment.date || !payment.amount) {\n        console.warn('Invalid payment object found:', payment);\n        continue;\n      }\n      const date = new Date(payment.date);\n      if (isNaN(date.getTime())) continue;\n\n      const existingEntry = entries.find(e =>\n        e.date.toDateString() === date.toDateString()\n      );\n\n      if (existingEntry) {\n        this.updateEntryWithPayment(entries, existingEntry, payment, paymentRules, mergeStrategy);\n      } else {\n        const newEntry = this.createDailyEntryFromInvoice(date, payment.amount, paymentRules);\n        entries.push(newEntry);\n      }\n    }\n  }\n\n  /**\n   * Update existing entry with payment information\n   */\n  private updateEntryWithPayment(entries: DailyEntry[], existingEntry: DailyEntry, payment: InvoiceEntry, paymentRules: PaymentRules, mergeStrategy: 'add' | 'replace' | 'max' | 'smart' = 'add'): void {\n    const index = entries.indexOf(existingEntry);\n    const currentPaid = existingEntry.paidAmount;\n    const dayOfWeek = existingEntry.date.getDay();\n    const rate = paymentRules.getRateForDay(dayOfWeek);\n\n    let newPaidAmount: number;\n    const paymentAmount = payment.amount;\n    switch (mergeStrategy) {\n      case 'replace':\n        newPaidAmount = paymentAmount;\n        break;\n      case 'max':\n        newPaidAmount = Math.max(currentPaid.amount, paymentAmount);\n        break;\n      case 'smart': {\n        // Smart strategy: if payment is significantly different (>20%), likely a new payment\n        const threshold = currentPaid.amount * 0.2;\n        newPaidAmount = Math.abs(paymentAmount - currentPaid.amount) > threshold\n          ? currentPaid.amount + paymentAmount\n          : paymentAmount;\n        break;\n      }\n      case 'add':\n      default:\n        newPaidAmount = currentPaid.amount + paymentAmount;\n        break;\n    }\n\n    entries[index] = new DailyEntry({\n      analysisId: '', // Will be set later\n      date: existingEntry.date,\n      consignments: existingEntry.consignments.count,\n      rate: rate.amount,\n      paidAmount: newPaidAmount,\n      pickups: existingEntry.pickups?.count || 0,\n      unloadingBonus: existingEntry.unloadingBonus.amount,\n      attendanceBonus: existingEntry.attendanceBonus.amount,\n      earlyBonus: existingEntry.earlyBonus.amount,\n    });\n  }\n\n  /**\n   * Create daily entry from invoice data\n   */\n  private createDailyEntryFromInvoice(date: Date, amount: number, paymentRules: PaymentRules): DailyEntry {\n    const dayOfWeek = date.getDay();\n    const rate = paymentRules.getRateForDay(dayOfWeek);\n\n    return new DailyEntry({\n      analysisId: '', // Will be set later\n      date,\n      consignments: 0,\n      rate: rate.amount,\n      paidAmount: amount,\n      pickups: 0,\n      unloadingBonus: 0,\n      attendanceBonus: 0,\n      earlyBonus: 0,\n    });\n  }\n\n  /**\n   * Save analysis to database\n   */\n  private async saveAnalysisToDatabase(analysis: Analysis, fileRecords: FileRecord[]): Promise<string> {\n    // Get analysis data\n    const analysisData = analysis.toJSON();\n    const periodStart = analysis.period.start;\n    const periodEnd = analysis.period.end;\n\n    // Create analysis record\n    const { data: analysisRecord, error: createError } = await analysisRepository.createAnalysis({\n      userId: analysis.userId,\n      fingerprint: analysis.fingerprint,\n      source: (analysisData.metadata?.source as AnalysisSource) || 'upload',\n      periodStart: periodStart.toISOString().split('T')[0],\n      periodEnd: periodEnd.toISOString().split('T')[0],\n      rulesVersion: 1, // Will be enhanced with versioning\n      workingDays: analysis.workingDaysCount,\n      totalConsignments: analysis.totalConsignments.count,\n      metadata: analysisData.metadata,\n    });\n\n    if (createError || !analysisRecord) {\n      throw new Error(createError?.message || 'Failed to create analysis record');\n    }\n\n    const analysisId = analysisRecord.id;\n\n    // Create daily entries\n    const dailyEntries = analysis.dailyEntries.map(entry => ({\n      date: entry.date.toISOString().split('T')[0],\n      day_of_week: entry.date.getDay(),\n      consignments: entry.consignments.count,\n      rate: entry.rate.amount,\n      base_payment: entry.basePayment.amount,\n      pickups: entry.pickups.count,\n      pickup_total: entry.pickupTotal.amount,\n      unloading_bonus: entry.unloadingBonus.amount,\n      attendance_bonus: entry.attendanceBonus.amount,\n      early_bonus: entry.earlyBonus.amount,\n      expected_total: entry.expectedTotal.amount,\n      paid_amount: entry.paidAmount.amount,\n      difference: entry.difference.amount,\n      status: entry.status,\n    }));\n\n    const { error: entriesError } = await analysisRepository.createDailyEntries(analysisId, dailyEntries);\n    if (entriesError) {\n      throw new Error(entriesError?.message || 'Failed to save daily entries');\n    }\n\n    // Create analysis totals\n    const { error: totalsError } = await analysisRepository.createAnalysisTotals(analysisId, {\n      base_total: analysis.baseTotal.amount,\n      pickup_total: analysis.pickupTotal.amount,\n      bonus_total: analysis.bonusTotal.amount,\n      expected_total: analysis.expectedTotal.amount,\n      paid_total: analysis.paidTotal.amount,\n      difference_total: analysis.differenceTotal.amount,\n    });\n    if (totalsError) {\n      throw new Error(totalsError);\n    }\n\n    // Create file records if any\n    if (fileRecords.length > 0) {\n      const { error: filesError } = await analysisRepository.createAnalysisFiles(analysisId, fileRecords);\n      if (filesError) {\n        throw new Error(filesError);\n      }\n    }\n\n    // Update status to completed\n    await analysisRepository.updateAnalysisStatus(analysisId, 'completed');\n\n    return analysisId;\n  }\n\n  /**\n   * Get analysis by ID\n   */\n  async getAnalysisById(analysisId: string): Promise<{ analysis: Analysis | null; error?: string }> {\n    try {\n      const { data: analysisData, error } = await analysisRepository.getAnalysisById(analysisId);\n      \n      if (error) {\n        return { analysis: null, error };\n      }\n\n      if (!analysisData) {\n        return { analysis: null, error: 'Analysis not found' };\n      }\n\n      // Convert database records back to domain entities\n      const analysis = this.convertDatabaseToAnalysis(analysisData);\n      \n      return { analysis };\n    } catch (error) {\n      return {\n        analysis: null,\n        error: error instanceof Error ? error.message : 'Failed to fetch analysis',\n      };\n    }\n  }\n\n  /**\n   * Get user analyses with pagination\n   */\n  async getUserAnalyses(\n    userId: string,\n    options?: {\n      limit?: number;\n      offset?: number;\n      search?: string;\n      status?: string;\n    }\n  ) {\n    return analysisRepository.getUserAnalyses(userId, options);\n  }\n\n  /**\n   * Get dashboard analytics\n   */\n  async getAnalyticsData(userId: string) {\n    return analysisRepository.getAnalyticsData(userId);\n  }\n\n  /**\n   * Delete analysis\n   */\n  async deleteAnalysis(analysisId: string) {\n    return analysisRepository.deleteAnalysis(analysisId);\n  }\n\n  /**\n   * Update analysis status\n   */\n  async updateAnalysisStatus(\n    analysisId: string, \n    status: 'pending' | 'processing' | 'completed' | 'error'\n  ): Promise<{ success: boolean; error?: string; analysis?: { id: string; status: string } }> {\n    try {\n      const result = await analysisRepository.updateAnalysisStatus(analysisId, status);\n      \n      if (!result.isSuccess) {\n        return {\n          success: false,\n          error: result.error.message,\n        };\n      }\n\n      return {\n        success: true,\n        analysis: {\n          id: analysisId,\n          status,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to update analysis status',\n      };\n    }\n  }\n\n  /**\n   * Utility methods\n   */\n  private async calculateFileHash(file: File): Promise<string> {\n    const buffer = await file.arrayBuffer();\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  private detectFileType(filename: string): FileType {\n    const lower = filename.toLowerCase();\n    if (lower.includes('runsheet') || lower.includes('dv_')) {\n      return 'runsheet';\n    } else if (lower.includes('invoice') || lower.includes('bill')) {\n      return 'invoice';\n    }\n    return 'other';\n  }\n\n  private convertDatabaseToAnalysis(data: AnalysisWithDetails): Analysis {\n    // Convert database records back to Analysis entity\n    // This would involve reconstructing DailyEntry objects and PaymentRules\n    // Implementation would be similar to Analysis.fromJSON()\n    \n    // For now, return a placeholder - this would be fully implemented\n    // based on the specific Analysis entity structure\n    throw new Error('convertDatabaseToAnalysis not fully implemented yet');\n  }\n\n  /**\n   * Type guard to check if an object is a valid payment object\n   */\n  private isValidPaymentObject(obj: unknown): obj is PaymentObject {\n    if (!obj || typeof obj !== 'object') return false;\n\n    const typedObj = obj as Record<string, unknown>;\n    return (typeof typedObj.date === 'string' || typeof typedObj.date === 'number' || typedObj.date instanceof Date) &&\n           (typeof typedObj.amount === 'number' || !isNaN(Number(typedObj.amount)));\n  }\n\n  /**\n   * Safely extract a number value from unknown type\n   */\n  private getNumberValue(value: unknown): number {\n    if (typeof value === 'number') {\n      return isNaN(value) ? 0 : value;\n    }\n    if (typeof value === 'string') {\n      const parsed = parseFloat(value);\n      return isNaN(parsed) ? 0 : parsed;\n    }\n    return 0;\n  }\n}\n\n// Export singleton instance\nexport const analysisService = new AnalysisService();","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/analysis-storage-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AnalysisMetadata' is defined but never used.","line":8,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":285,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Analysis Storage Service\n * High-level interface for storing analysis data with compression\n * Replaces direct localStorage usage throughout the application\n */\n\nimport { CompressedStorageService } from './compressed-storage-service';\nimport { StringKeyObject, AnalysisMetadata } from '@/types/core';\n\n// Declare LZString on window for original HTML system compatibility\ndeclare global {\n  interface Window {\n    LZString?: {\n      decompressFromUTF16: (input: string) => string | null;\n      compressToUTF16: (input: string) => string;\n    };\n  }\n}\n\nexport interface StorageKeys {\n  ANALYSES: 'pa:analyses:v9';\n  RULES: 'pa:rules:v9';\n  SESSION: 'pa:session:v9';\n  UPLOADED_FILES: 'uploadedFiles_v9';\n  USER_PREFERENCES: 'pa:preferences:v9';\n}\n\nexport class AnalysisStorageService {\n  // Storage keys matching original HTML system\n  static readonly KEYS: StorageKeys = {\n    ANALYSES: 'pa:analyses:v9',\n    RULES: 'pa:rules:v9',\n    SESSION: 'pa:session:v9',\n    UPLOADED_FILES: 'uploadedFiles_v9',\n    USER_PREFERENCES: 'pa:preferences:v9'\n  };\n\n  /**\n   * Store analysis data with compression\n   */\n  static saveAnalyses(analyses: Record<string, StringKeyObject>): boolean {\n    return CompressedStorageService.setItem(this.KEYS.ANALYSES, analyses);\n  }\n\n  /**\n   * Load analysis data\n   */\n  static loadAnalyses(): Record<string, StringKeyObject> {\n    // First try the new React key\n    let analyses = CompressedStorageService.getItem(this.KEYS.ANALYSES);\n    \n    if (!analyses || Object.keys(analyses).length === 0) {\n      // Fallback to original HTML system key\n      const originalKey = 'paymentAnalyzer_v9_analyses';\n      try {\n        const rawData = localStorage.getItem(originalKey);\n        if (rawData) {\n          console.log('📦 Found original HTML system data, attempting to load...');\n          // Try to decompress if it's LZ-string compressed\n          if (window.LZString) {\n            try {\n              const decompressed = window.LZString.decompressFromUTF16(rawData);\n              if (decompressed) {\n                analyses = JSON.parse(decompressed);\n                console.log('📦 Successfully loaded and decompressed original data');\n              } else {\n                // Not compressed, try direct parsing\n                analyses = JSON.parse(rawData);\n                console.log('📦 Successfully loaded original uncompressed data');\n              }\n            } catch {\n              // Try direct parsing if decompression fails\n              analyses = JSON.parse(rawData);\n              console.log('📦 Successfully loaded original data (direct parse)');\n            }\n          } else {\n            analyses = JSON.parse(rawData);\n            console.log('📦 Successfully loaded original data (no LZString)');\n          }\n        }\n      } catch (error) {\n        console.error('Failed to load original HTML system data:', error);\n        analyses = {};\n      }\n    }\n\n    return (analyses as Record<string, StringKeyObject>) || {};\n  }\n\n  /**\n   * Store payment rules\n   */\n  static saveRules(rules: StringKeyObject): boolean {\n    return CompressedStorageService.setItem(this.KEYS.RULES, rules);\n  }\n\n  /**\n   * Load payment rules\n   */\n  static loadRules(): StringKeyObject | null {\n    return CompressedStorageService.getItem(this.KEYS.RULES);\n  }\n\n  /**\n   * Store session data\n   */\n  static saveSession(sessionData: StringKeyObject): boolean {\n    return CompressedStorageService.setItem(this.KEYS.SESSION, sessionData);\n  }\n\n  /**\n   * Load session data\n   */\n  static loadSession(): StringKeyObject | null {\n    return CompressedStorageService.getItem(this.KEYS.SESSION);\n  }\n\n  /**\n   * Store uploaded files metadata\n   */\n  static saveUploadedFiles(files: StringKeyObject[]): boolean {\n    return CompressedStorageService.setItem(this.KEYS.UPLOADED_FILES, files);\n  }\n\n  /**\n   * Load uploaded files metadata\n   */\n  static loadUploadedFiles(): StringKeyObject[] {\n    return CompressedStorageService.getItem(this.KEYS.UPLOADED_FILES) || [];\n  }\n\n  /**\n   * Store user preferences\n   */\n  static savePreferences(preferences: StringKeyObject): boolean {\n    return CompressedStorageService.setItem(this.KEYS.USER_PREFERENCES, preferences);\n  }\n\n  /**\n   * Load user preferences\n   */\n  static loadPreferences(): StringKeyObject | null {\n    return CompressedStorageService.getItem(this.KEYS.USER_PREFERENCES);\n  }\n\n  /**\n   * Store single analysis\n   */\n  static saveAnalysis(analysisId: string, analysisData: StringKeyObject): boolean {\n    const analyses = this.loadAnalyses();\n    analyses[analysisId] = analysisData;\n    return this.saveAnalyses(analyses);\n  }\n\n  /**\n   * Load single analysis\n   */\n  static loadAnalysis(analysisId: string): StringKeyObject | null {\n    const analyses = this.loadAnalyses();\n    return analyses[analysisId] || null;\n  }\n\n  /**\n   * Delete analysis\n   */\n  static deleteAnalysis(analysisId: string): boolean {\n    const analyses = this.loadAnalyses();\n    if (analyses[analysisId]) {\n      delete analyses[analysisId];\n      return this.saveAnalyses(analyses);\n    }\n    return true;\n  }\n\n  /**\n   * Get storage statistics\n   */\n  static getStorageStats() {\n    const metrics = CompressedStorageService.getStorageMetrics();\n    const usage = CompressedStorageService.getStorageUsage();\n    \n    return {\n      compression: {\n        totalItems: metrics.totalItems,\n        originalSize: this.formatBytes(metrics.totalOriginalSize),\n        compressedSize: this.formatBytes(metrics.totalCompressedSize),\n        savedBytes: this.formatBytes(metrics.savedBytes),\n        savedPercentage: metrics.savedPercentage.toFixed(1) + '%',\n        compressionRatio: (metrics.compressionRatio * 100).toFixed(1) + '%'\n      },\n      usage: {\n        used: this.formatBytes(usage.used),\n        available: this.formatBytes(usage.available),\n        percentage: usage.percentage.toFixed(1) + '%',\n        isNearLimit: usage.percentage > 80\n      },\n      breakdown: this.getStorageBreakdown()\n    };\n  }\n\n  /**\n   * Get detailed storage breakdown by key\n   */\n  private static getStorageBreakdown() {\n    const breakdown: Record<string, { size: string; items: number }> = {};\n    \n    Object.values(this.KEYS).forEach(key => {\n      const data = CompressedStorageService.getItem(key);\n      if (data) {\n        const size = new Blob([JSON.stringify(data)]).size;\n        breakdown[key] = {\n          size: this.formatBytes(size),\n          items: Array.isArray(data) ? data.length : (typeof data === 'object' ? Object.keys(data).length : 1)\n        };\n      }\n    });\n\n    return breakdown;\n  }\n\n  /**\n   * Migrate from legacy localStorage to compressed storage\n   */\n  static migrateLegacyData(): {\n    migrated: string[];\n    skipped: string[];\n    errors: string[];\n  } {\n    return CompressedStorageService.migrateLegacyData();\n  }\n\n  /**\n   * Clear all analysis data (keep user preferences)\n   */\n  static clearAnalysisData(): void {\n    CompressedStorageService.removeItem(this.KEYS.ANALYSES);\n    CompressedStorageService.removeItem(this.KEYS.SESSION);\n    CompressedStorageService.removeItem(this.KEYS.UPLOADED_FILES);\n  }\n\n  /**\n   * Clear all data\n   */\n  static clearAllData(): void {\n    CompressedStorageService.clear();\n  }\n\n  /**\n   * Check if storage is healthy (not corrupted)\n   */\n  static checkStorageHealth(): {\n    isHealthy: boolean;\n    issues: string[];\n    recommendations: string[];\n  } {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n\n    try {\n      // Test basic functionality\n      const testKey = 'health-check-test';\n      const testData = { test: true, timestamp: Date.now() };\n      \n      CompressedStorageService.setItem(testKey, testData);\n      const retrieved = CompressedStorageService.getItem(testKey);\n      CompressedStorageService.removeItem(testKey);\n\n      if (!retrieved || typeof retrieved !== 'object' || !('test' in retrieved) || retrieved.test !== true) {\n        issues.push('Basic read/write operations failing');\n      }\n\n      // Check storage usage\n      const usage = CompressedStorageService.getStorageUsage();\n      if (usage.percentage > 90) {\n        issues.push('Storage usage over 90%');\n        recommendations.push('Clear old analysis data or export to external storage');\n      } else if (usage.percentage > 80) {\n        recommendations.push('Consider clearing old data to maintain performance');\n      }\n\n      // Check for corrupted data\n      Object.values(this.KEYS).forEach(key => {\n        try {\n          CompressedStorageService.getItem(key);\n        } catch (error) {\n          issues.push(`Corrupted data in key: ${key}`);\n          recommendations.push(`Clear and recreate data for key: ${key}`);\n        }\n      });\n\n    } catch (error) {\n      issues.push('Storage system failure: ' + (error instanceof Error ? error.message : 'Unknown error'));\n      recommendations.push('Clear browser data and refresh the application');\n    }\n\n    return {\n      isHealthy: issues.length === 0,\n      issues,\n      recommendations\n    };\n  }\n\n  /**\n   * Export all data for backup\n   */\n  static exportAllData(): {\n    version: string;\n    timestamp: number;\n    data: Record<string, StringKeyObject>;\n    metrics: StringKeyObject;\n  } {\n    const exportData: Record<string, StringKeyObject> = {};\n    \n    Object.values(this.KEYS).forEach(key => {\n      const data = CompressedStorageService.getItem(key);\n      if (data) {\n        exportData[key] = data as StringKeyObject;\n      }\n    });\n\n    return {\n      version: '9.0.0',\n      timestamp: Date.now(),\n      data: exportData,\n      metrics: this.getStorageStats()\n    };\n  }\n\n  /**\n   * Import data from backup\n   */\n  static importData(backupData: StringKeyObject): {\n    success: boolean;\n    imported: string[];\n    errors: string[];\n  } {\n    const result = {\n      success: false,\n      imported: [] as string[],\n      errors: [] as string[]\n    };\n\n    try {\n      if (!backupData.data || !backupData.version) {\n        result.errors.push('Invalid backup data format');\n        return result;\n      }\n\n      Object.entries(backupData.data).forEach(([key, data]) => {\n        try {\n          const success = CompressedStorageService.setItem(key, data);\n          if (success) {\n            result.imported.push(key);\n          } else {\n            result.errors.push(`Failed to import: ${key}`);\n          }\n        } catch (error) {\n          result.errors.push(`Error importing ${key}: ${error}`);\n        }\n      });\n\n      result.success = result.errors.length === 0;\n      \n    } catch (error) {\n      result.errors.push('Import failed: ' + (error instanceof Error ? error.message : 'Unknown error'));\n    }\n\n    return result;\n  }\n\n  /**\n   * Format bytes for display\n   */\n  private static formatBytes(bytes: number): string {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n}\n\nexport default AnalysisStorageService;","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/analytics-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StringKeyObject' is defined but never used.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { analysisRepository } from '@/lib/repositories/analysis-repository';\nimport { AppError, ErrorCodes, Result } from '@/lib/utils/errors';\nimport type { KPIData } from '@/components/charts/kpi-cards';\nimport type { RevenueDataPoint } from '@/components/charts/revenue-chart';\nimport { StringKeyObject } from '@/types/core';\nimport type { AnalysisWithDetails } from '@/lib/repositories/analysis-repository';\n\nexport interface AnalyticsData {\n  kpis: KPIData[];\n  revenueChart: RevenueDataPoint[];\n  trends: {\n    earnings: number;\n    consignments: number;\n    efficiency: number;\n    accuracy: number;\n  };\n}\n\nexport interface AnalyticsOptions {\n  userId: string;\n  period: string; // '7d', '30d', '3m', '6m', '1y'\n  compareWith?: string; // Previous period for trend calculation\n}\n\nexport class AnalyticsService {\n  private readonly cache = new Map<string, { data: AnalyticsData; timestamp: number }>();\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n  /**\n   * Get comprehensive analytics data for dashboard with caching\n   */\n  async getAnalyticsData(options: AnalyticsOptions): Promise<Result<AnalyticsData>> {\n    try {\n      const { userId, period } = options;\n      \n      // Check cache first\n      const cacheKey = this.generateCacheKey(options);\n      const cached = this.getCachedData(cacheKey);\n      \n      if (cached) {\n        return Result.success(cached);\n      }\n\n      // Validate inputs\n      if (!userId?.trim()) {\n        return Result.failure(\n          new AppError(\n            'User ID is required',\n            ErrorCodes.VALIDATION_REQUIRED_FIELD,\n            400\n          )\n        );\n      }\n\n      const validPeriods = ['7d', '30d', '3m', '6m', '1y'];\n      if (!validPeriods.includes(period)) {\n        return Result.failure(\n          new AppError(\n            `Invalid period. Must be one of: ${validPeriods.join(', ')}`,\n            ErrorCodes.VALIDATION_INVALID_FORMAT,\n            400\n          )\n        );\n      }\n      \n      // Note: Date ranges calculated but not used in current implementation\n      // Future enhancement: Use date ranges for filtering queries\n      \n      // Get current period analyses\n      const currentResult = await analysisRepository.getUserAnalyses(userId, {\n        limit: 1000, // Get all for the period\n      });\n      \n      if (currentResult.error) {\n        return Result.failure(\n          new AppError(\n            'Failed to fetch current period data',\n            ErrorCodes.DATABASE_CONNECTION_ERROR,\n            500,\n            false,\n            { originalError: currentResult.error }\n          )\n        );\n      }\n      \n      // Get previous period for trend comparison\n      const previousResult = await analysisRepository.getUserAnalyses(userId, {\n        limit: 1000,\n      });\n      \n      const currentAnalyses = currentResult.data || [];\n      const previousAnalyses = previousResult.data || [];\n      \n      // Process data into analytics format\n      const kpis = await this.calculateKPIs(currentAnalyses, previousAnalyses);\n      const revenueChart = this.generateRevenueChartData(currentAnalyses);\n      const trends = this.calculateTrends(currentAnalyses, previousAnalyses);\n      \n      const analyticsData: AnalyticsData = {\n        kpis,\n        revenueChart,\n        trends,\n      };\n\n      // Cache the result\n      this.setCachedData(cacheKey, analyticsData);\n      \n      return Result.success(analyticsData);\n    } catch (error) {\n      return Result.failure(\n        new AppError(\n          'Failed to fetch analytics data',\n          ErrorCodes.INTERNAL_ERROR,\n          500,\n          false,\n          { originalError: error instanceof Error ? error.message : 'Unknown error' }\n        )\n      );\n    }\n  }\n\n  /**\n   * Calculate KPIs with trend comparison\n   */\n  private async calculateKPIs(currentAnalyses: AnalysisWithDetails[], previousAnalyses: AnalysisWithDetails[]): Promise<KPIData[]> {\n    // Current period totals\n    const currentTotals = this.calculatePeriodTotals(currentAnalyses);\n    const previousTotals = this.calculatePeriodTotals(previousAnalyses);\n    \n    const kpis: KPIData[] = [\n      {\n        id: 'total_earnings',\n        label: 'Total Earnings',\n        value: currentTotals.totalEarnings,\n        format: 'currency',\n        icon: 'dollar',\n        color: 'green',\n        change: this.calculatePercentageChange(currentTotals.totalEarnings, previousTotals.totalEarnings),\n        changeLabel: 'vs previous period',\n      },\n      {\n        id: 'working_days',\n        label: 'Working Days',\n        value: currentTotals.workingDays,\n        format: 'number',\n        icon: 'calendar',\n        color: 'blue',\n        change: this.calculatePercentageChange(currentTotals.workingDays, previousTotals.workingDays),\n        changeLabel: 'vs previous period',\n      },\n      {\n        id: 'avg_daily',\n        label: 'Avg Daily Revenue',\n        value: currentTotals.workingDays > 0 ? currentTotals.totalEarnings / currentTotals.workingDays : 0,\n        format: 'currency',\n        icon: 'trending',\n        color: 'purple',\n        change: this.calculatePercentageChange(\n          currentTotals.totalEarnings / (currentTotals.workingDays || 1),\n          previousTotals.totalEarnings / (previousTotals.workingDays || 1)\n        ),\n        changeLabel: 'vs previous period',\n      },\n      {\n        id: 'consignments',\n        label: 'Total Consignments',\n        value: currentTotals.totalConsignments,\n        format: 'number',\n        icon: 'activity',\n        color: 'amber',\n        change: this.calculatePercentageChange(currentTotals.totalConsignments, previousTotals.totalConsignments),\n        changeLabel: 'vs previous period',\n      },\n    ];\n    \n    return kpis;\n  }\n\n  /**\n   * Generate revenue chart data points\n   */\n  private generateRevenueChartData(analyses: AnalysisWithDetails[]): RevenueDataPoint[] {\n    try {\n      // Group analyses by period (daily, weekly, or monthly based on data volume)\n      const groupedData = this.groupAnalysesByPeriod(analyses);\n      \n      return groupedData\n        .filter(group => {\n          // Ensure valid period data\n          if (!group.period || typeof group.period !== 'string' || group.period.trim().length <= 1) {\n            console.warn('Filtering out invalid period group:', group);\n            return false;\n          }\n          return true;\n        })\n        .map((group, index) => ({\n          period: group.period.trim(),\n          expected: Math.round((group.expectedTotal || 0) * 100) / 100,\n          actual: Math.round((group.paidTotal || 0) * 100) / 100,\n          difference: Math.round(((group.paidTotal || 0) - (group.expectedTotal || 0)) * 100) / 100,\n          consignments: group.consignments || 0,\n          // Add a unique identifier for React keys with additional safety\n          id: `revenue-${index}-${Date.now()}-${group.period.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}`,\n        }));\n    } catch (error) {\n      console.error('Error generating revenue chart data:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Calculate trends between periods\n   */\n  private calculateTrends(currentAnalyses: AnalysisWithDetails[], previousAnalyses: AnalysisWithDetails[]) {\n    const current = this.calculatePeriodTotals(currentAnalyses);\n    const previous = this.calculatePeriodTotals(previousAnalyses);\n    \n    return {\n      earnings: this.calculatePercentageChange(current.totalEarnings, previous.totalEarnings),\n      consignments: this.calculatePercentageChange(current.totalConsignments, previous.totalConsignments),\n      efficiency: this.calculatePercentageChange(\n        current.totalEarnings / (current.workingDays || 1),\n        previous.totalEarnings / (previous.workingDays || 1)\n      ),\n      accuracy: this.calculateAccuracyTrend(currentAnalyses, previousAnalyses),\n    };\n  }\n\n  /**\n   * Calculate period totals from analyses\n   */\n  private calculatePeriodTotals(analyses: AnalysisWithDetails[]) {\n    return analyses.reduce((totals, analysis) => {\n      const analysisTotal = Array.isArray(analysis.analysis_totals) ? analysis.analysis_totals[0] : analysis.analysis_totals;\n      const expectedTotal = analysisTotal?.expected_total || 0;\n      const paidTotal = analysisTotal?.paid_total || 0;\n      \n      return {\n        totalEarnings: totals.totalEarnings + expectedTotal,\n        totalPaid: totals.totalPaid + paidTotal,\n        workingDays: totals.workingDays + (analysis.working_days || 0),\n        totalConsignments: totals.totalConsignments + (analysis.total_consignments || 0),\n        analysisCount: totals.analysisCount + 1,\n      };\n    }, {\n      totalEarnings: 0,\n      totalPaid: 0,\n      workingDays: 0,\n      totalConsignments: 0,\n      analysisCount: 0,\n    });\n  }\n\n  /**\n   * Group analyses by time period for chart display\n   */\n  private groupAnalysesByPeriod(analyses: AnalysisWithDetails[]) {\n    try {\n      // Simple grouping by month for now\n      const groups = new Map();\n      \n      if (!Array.isArray(analyses)) {\n        console.warn('Invalid analyses data provided to groupAnalysesByPeriod');\n        return [];\n      }\n      \n      analyses.forEach((analysis, index) => {\n        try {\n          // Validate period_start date\n          if (!analysis?.period_start) {\n            console.warn(`Analysis at index ${index} has no period_start date, skipping`);\n            return;\n          }\n          \n          const date = new Date(analysis.period_start);\n          \n          // Check if date is valid\n          if (isNaN(date.getTime())) {\n            console.warn(`Invalid date found in analysis at index ${index}: ${analysis.period_start}, skipping`);\n            return;\n          }\n          \n          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n          \n          if (!groups.has(monthKey)) {\n            // Generate a safe period label\n            let periodLabel;\n            try {\n              periodLabel = date.toLocaleDateString('en-UK', { year: 'numeric', month: 'short' });\n              // Ensure the period label is valid\n              if (!periodLabel || periodLabel === 'Invalid Date' || periodLabel.length <= 1) {\n                throw new Error('Invalid date formatting result');\n              }\n            } catch (dateError) {\n              console.warn(`Failed to format date ${analysis.period_start}, using fallback format:`, dateError);\n              periodLabel = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n            }\n            \n            groups.set(monthKey, {\n              period: periodLabel,\n              expectedTotal: 0,\n              paidTotal: 0,\n              consignments: 0,\n            });\n          }\n          \n          const group = groups.get(monthKey);\n          const analysisTotal = Array.isArray(analysis.analysis_totals) ? analysis.analysis_totals[0] : analysis.analysis_totals;\n          const expectedTotal = analysisTotal?.expected_total || 0;\n          const paidTotal = analysisTotal?.paid_total || 0;\n          \n          group.expectedTotal += expectedTotal;\n          group.paidTotal += paidTotal;\n          group.consignments += analysis.total_consignments || 0;\n        } catch (error) {\n          console.warn(`Error processing analysis at index ${index}:`, error);\n        }\n      });\n      \n      return Array.from(groups.values())\n        .filter(group => group.period && group.period.trim().length > 1) // Filter out invalid periods\n        .sort((a, b) => {\n          // Safe period comparison\n          const periodA = a.period || '';\n          const periodB = b.period || '';\n          return periodA.localeCompare(periodB);\n        });\n    } catch (error) {\n      console.error('Error grouping analyses by period:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Calculate percentage change between two values\n   */\n  private calculatePercentageChange(current: number, previous: number): number {\n    if (previous === 0) return current > 0 ? 100 : 0;\n    return ((current - previous) / previous) * 100;\n  }\n\n  /**\n   * Calculate payment accuracy trend\n   */\n  private calculateAccuracyTrend(currentAnalyses: AnalysisWithDetails[], previousAnalyses: AnalysisWithDetails[]): number {\n    const calculateAccuracy = (analyses: AnalysisWithDetails[]) => {\n      if (analyses.length === 0) return 100;\n      \n      const accuratePayments = analyses.filter(analysis => {\n        const analysisTotal = Array.isArray(analysis.analysis_totals) ? analysis.analysis_totals[0] : analysis.analysis_totals;\n        const difference = analysisTotal?.difference_total || 0;\n        return Math.abs(difference) < 0.01; // Within 1p\n      }).length;\n      \n      return (accuratePayments / analyses.length) * 100;\n    };\n    \n    const currentAccuracy = calculateAccuracy(currentAnalyses);\n    const previousAccuracy = calculateAccuracy(previousAnalyses);\n    \n    return this.calculatePercentageChange(currentAccuracy, previousAccuracy);\n  }\n\n  /**\n   * Get date range for period string\n   */\n  private getPeriodDateRange(period: string) {\n    const now = new Date();\n    const daysMap: Record<string, number> = {\n      '7d': 7,\n      '30d': 30,\n      '3m': 90,\n      '6m': 180,\n      '1y': 365,\n    };\n    \n    const days = daysMap[period] || 30;\n    const startDate = new Date(now);\n    startDate.setDate(now.getDate() - days);\n    \n    return { startDate, endDate: now };\n  }\n\n  /**\n   * Get previous period date range for comparison\n   */\n  private getPreviousPeriodDateRange(period: string) {\n    const current = this.getPeriodDateRange(period);\n    const periodLength = current.endDate.getTime() - current.startDate.getTime();\n    \n    const endDate = new Date(current.startDate);\n    const startDate = new Date(current.startDate.getTime() - periodLength);\n    \n    return { startDate, endDate };\n  }\n\n  /**\n   * Forecast earnings for next period\n   */\n  async forecastEarnings(userId: string, daysAhead: number = 7): Promise<{ forecast: number; confidence: number }> {\n    try {\n      // Get recent analyses for trend calculation\n      const { data: analyses } = await analysisRepository.getUserAnalyses(userId, {\n        limit: 50,\n        orderBy: 'created_at',\n        order: 'desc',\n      });\n      \n      if (!analyses || analyses.length < 3) {\n        return { forecast: 0, confidence: 0 };\n      }\n      \n      // Simple linear regression on daily averages\n      const dailyAverages = analyses.map(analysis => {\n        const expectedTotal = analysis.analysis_totals?.expected_total || 0;\n        const workingDays = analysis.working_days || 1;\n        return expectedTotal / workingDays;\n      });\n      \n      // Calculate trend\n      const recentAverage = dailyAverages.slice(0, 10).reduce((a, b) => a + b, 0) / Math.min(10, dailyAverages.length);\n      const forecast = recentAverage * daysAhead;\n      const confidence = Math.min(95, analyses.length * 5); // Higher confidence with more data\n      \n      return { forecast, confidence };\n    } catch (error) {\n      // Log the error for debugging purposes\n      console.error('Error forecasting earnings:', {\n        userId,\n        daysAhead,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      // Return default values when forecasting fails\n      return { forecast: 0, confidence: 0 };\n    }\n  }\n  /**\n   * Cache management methods\n   */\n  private generateCacheKey(options: AnalyticsOptions): string {\n    return `analytics:${options.userId}:${options.period}:${options.compareWith || 'none'}`;\n  }\n\n  private getCachedData(key: string): AnalyticsData | null {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {\n      return cached.data;\n    }\n    this.cache.delete(key);\n    return null;\n  }\n\n  private setCachedData(key: string, data: AnalyticsData): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Clear cache for a specific user or all cache\n   */\n  clearCache(userId?: string): void {\n    if (userId) {\n      for (const [key] of this.cache.entries()) {\n        if (key.includes(`analytics:${userId}:`)) {\n          this.cache.delete(key);\n        }\n      }\n    } else {\n      this.cache.clear();\n    }\n  }\n}\n\n// Export singleton instance\nexport const analyticsService = new AnalyticsService();","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/auth-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/compressed-storage-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/export-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/file-fingerprint-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/inline-report-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/payment-calculation-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/preferences-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/progress-tracking-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/session-recovery-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/step3-analysis-service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StringKeyObject' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weeks' is defined but never used.","line":139,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":139,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Step 3 Analysis Service\n * Equivalent to displayAnalysisResults and related functions from original HTML\n */\n\nimport { PaymentCalculationService, PaymentTotals, WeekCalculation, DayCalculation } from './payment-calculation-service';\nimport { v4 as uuidv4 } from 'uuid';\nimport { StringKeyObject, ManualEntry } from '@/types/core';\n\ninterface DailyDataEntry {\n  consignments: number;\n  basePayment: number;\n  expectedTotal: number;\n  paidAmount: number;\n  unloadingBonus: number;\n  attendanceBonus: number;\n  earlyBonus: number;\n  pickupCount: number;\n  pickupTotal: number;\n  pickups: number;\n  rate: number;\n  status: string;\n}\n\nexport interface Step3AnalysisData {\n  id: string;\n  totals: PaymentTotals;\n  weeks: WeekCalculation[];\n  days: DayCalculation[];\n  metadata: {\n    analysisId: string;\n    createdAt: Date;\n    analysisDate: string;\n    inputMethod: 'upload' | 'manual';\n    totalFiles?: number;\n    totalEntries: number;\n    overallStatus: string;\n    periodRange: string;\n  };\n}\n\nexport interface AnalysisInput {\n  results?: DayCalculation[];\n  totals?: PaymentTotals;\n  weeks?: WeekCalculation[];\n  files?: File[];\n  manualEntries?: ManualEntry[];\n  inputMethod: 'upload' | 'manual';\n}\n\nexport class Step3AnalysisService {\n  private static calculationService = new PaymentCalculationService();\n\n  /**\n   * Main analysis processing function\n   * Equivalent to the analyze() function in original HTML\n   */\n  static async processAnalysis(input: AnalysisInput): Promise<Step3AnalysisData | null> {\n    try {\n      const { inputMethod, files, manualEntries } = input;\n\n      let dayCalculations: DayCalculation[] = [];\n\n      // Process based on input method\n      if (inputMethod === 'manual' && manualEntries?.length) {\n        dayCalculations = this.processManualEntries(manualEntries);\n      } else if (inputMethod === 'upload' && files?.length) {\n        // For file upload, we would normally process PDF files here\n        // For now, return null - this should be handled by PDF processing\n        console.log('📄 File processing would happen here');\n        return null;\n      } else if (input.results) {\n        // Use pre-calculated results\n        dayCalculations = input.results;\n      } else {\n        console.warn('No valid data for analysis');\n        return null;\n      }\n\n      // Calculate totals and weeks\n      const totals = this.calculationService.calculateTotals(dayCalculations);\n      const weeks = this.calculationService.groupByWeeks(dayCalculations);\n\n      // Generate metadata\n      const metadata = this.generateMetadata(dayCalculations, totals, weeks);\n\n      const analysisData: Step3AnalysisData = {\n        id: metadata.analysisId,\n        totals,\n        weeks,\n        days: dayCalculations,\n        metadata\n      };\n\n      console.log('📊 Step 3 analysis complete:', analysisData);\n      return analysisData;\n\n    } catch (error) {\n      console.error('❌ Step 3 analysis failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Process manual entries into day calculations\n   */\n  private static processManualEntries(manualEntries: ManualEntry[]): DayCalculation[] {\n    const dailyData: Record<string, DailyDataEntry> = {};\n\n    // Convert manual entries to daily data format\n    manualEntries.forEach((entry) => {\n      if (entry.date) {\n        dailyData[entry.date] = {\n          consignments: entry.consignments || 0,\n          basePayment: 0, // Will be calculated\n          expectedTotal: 0, // Will be calculated\n          paidAmount: entry.totalPay || 0,\n          unloadingBonus: 0, // Will be calculated\n          attendanceBonus: 0, // Will be calculated\n          earlyBonus: 0, // Will be calculated\n          pickups: entry.pickups || 0,\n          pickupCount: entry.pickups || 0,\n          pickupTotal: 0, // Will be calculated\n          rate: 0, // Will be calculated\n          status: 'manual'\n        };\n      }\n    });\n\n    return this.calculationService.processDailyData(dailyData);\n  }\n\n  /**\n   * Generate analysis metadata\n   */\n  private static generateMetadata(\n    days: DayCalculation[], \n    totals: PaymentTotals, \n    weeks: WeekCalculation[]\n  ): Step3AnalysisData['metadata'] {\n    const sortedDays = days.filter(d => d.consignments > 0 || d.paidAmount > 0)\n                          .sort((a, b) => a.date.localeCompare(b.date));\n    \n    const firstDay = sortedDays[0]?.date;\n    const lastDay = sortedDays[sortedDays.length - 1]?.date;\n    \n    let periodRange = 'No data';\n    if (firstDay && lastDay) {\n      const startDate = new Date(firstDay).toLocaleDateString('en-GB');\n      const endDate = new Date(lastDay).toLocaleDateString('en-GB');\n      periodRange = firstDay === lastDay ? startDate : `${startDate} - ${endDate}`;\n    }\n\n    const overallStatus = totals.differenceTotal >= 0 ? \n      'Payment Complete - Favorable' : \n      'Payment Incomplete - Review Required';\n\n    return {\n      analysisId: uuidv4(),\n      createdAt: new Date(),\n      analysisDate: new Date().toISOString().split('T')[0],\n      inputMethod: 'upload' as const,\n      totalEntries: days.length,\n      overallStatus,\n      periodRange\n    };\n  }\n\n  /**\n   * Generate quick summary data for Step 3 cards\n   * Equivalent to generateStep3SummaryCards data preparation\n   */\n  static generateQuickSummary(analysisData: Step3AnalysisData) {\n    const { totals } = analysisData;\n    \n    return {\n      totalActual: totals.paidTotal,\n      totalExpected: totals.expectedTotal,\n      difference: totals.differenceTotal,\n      workingDays: totals.workingDays,\n      dailyAverage: totals.workingDays > 0 ? totals.expectedTotal / totals.workingDays : 0,\n      isDifferencePositive: totals.differenceTotal >= 0\n    };\n  }\n\n  /**\n   * Validate analysis data\n   * Equivalent to validation logic in original\n   */\n  static validateAnalysisData(analysisData: Step3AnalysisData | null): {\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n  } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!analysisData) {\n      errors.push('No analysis data available');\n      return { isValid: false, errors, warnings };\n    }\n\n    const { days, totals, weeks } = analysisData;\n\n    // Basic validation\n    if (!days.length) {\n      errors.push('No daily data found');\n    }\n\n    if (!weeks.length) {\n      errors.push('No weekly data found');\n    }\n\n    if (totals.workingDays === 0) {\n      warnings.push('No working days detected');\n    }\n\n    if (totals.totalConsignments === 0) {\n      warnings.push('No consignments recorded');\n    }\n\n    // Business rule validation\n    days.forEach((day: DayCalculation) => {\n      if (day.day === 'Sunday' && (day.consignments > 0 || day.paidAmount > 0)) {\n        warnings.push(`Work recorded on Sunday ${day.date} - unusual`);\n      }\n\n      if (day.day === 'Monday' && day.unloadingBonus > 0) {\n        errors.push(`Monday ${day.date} has unloading bonus - should be £0.00`);\n      }\n\n      if (day.day === 'Saturday' && (day.attendanceBonus > 0 || day.earlyBonus > 0)) {\n        errors.push(`Saturday ${day.date} has attendance/early bonus - should be £0.00`);\n      }\n\n      if (Math.abs(day.difference) > 100) {\n        warnings.push(`Large payment difference on ${day.date}: £${day.difference.toFixed(2)}`);\n      }\n    });\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Format analysis data for reports\n   * Equivalent to generateAnalysisDataForReports in original\n   */\n  static formatForReports(analysisData: Step3AnalysisData) {\n    const { totals, weeks, days, metadata } = analysisData;\n\n    return {\n      results: days,\n      totals,\n      weeks,\n      metadata: {\n        ...metadata,\n        rulesVersion: '9.0.0',\n        calculatedAt: new Date().toISOString()\n      }\n    };\n  }\n\n  /**\n   * Prepare data for dashboard/history saving\n   */\n  static prepareForStorage(analysisData: Step3AnalysisData, inputMethod: 'upload' | 'manual') {\n    const { totals, weeks, days, metadata } = analysisData;\n\n    return {\n      analysisData: {\n        totals,\n        weeks,\n        days,\n        metadata\n      },\n      summary: {\n        workingDays: totals.workingDays,\n        totalConsignments: totals.totalConsignments,\n        expectedTotal: totals.expectedTotal,\n        paidTotal: totals.paidTotal,\n        difference: totals.differenceTotal,\n        status: metadata.overallStatus,\n        periodRange: metadata.periodRange\n      },\n      inputMethod,\n      processedAt: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Check if analysis should show detailed report vs individual week reports\n   */\n  static shouldShowDetailedReport(analysisData: Step3AnalysisData): boolean {\n    return analysisData.weeks.length === 1;\n  }\n\n  /**\n   * Get analysis status for UI display\n   */\n  static getAnalysisStatus(analysisData: Step3AnalysisData | null) {\n    if (!analysisData) {\n      return {\n        status: 'empty',\n        message: 'No analysis data available',\n        color: 'gray'\n      };\n    }\n\n    const { totals } = analysisData;\n    const difference = totals.differenceTotal;\n\n    if (difference > 0) {\n      return {\n        status: 'favorable',\n        message: 'Payment Complete - Favorable',\n        color: 'green'\n      };\n    } else if (difference === 0) {\n      return {\n        status: 'exact',\n        message: 'Payment Complete - Exact Match',\n        color: 'blue'\n      };\n    } else {\n      return {\n        status: 'unfavorable', \n        message: 'Payment Incomplete - Review Required',\n        color: 'red'\n      };\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/services/week-navigation-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/stores/auth-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/stores/preferences-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/supabase/client.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'columns' is defined but never used.","line":87,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'values' is defined but never used.","line":88,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'values' is defined but never used.","line":89,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'values' is defined but never used.","line":91,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":92,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":92,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":93,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":93,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":94,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":94,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":95,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":95,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":96,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":96,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":97,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":97,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":98,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pattern' is defined but never used.","line":98,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":99,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":23,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pattern' is defined but never used.","line":99,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":100,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":100,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":101,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'values' is defined but never used.","line":101,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":102,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":102,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":103,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":103,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":103,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":103,"endColumn":44,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":104,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":104,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":105,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":105,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":106,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":106,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":107,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":107,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":107,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":107,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":108,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":108,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":109,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":109,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":110,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is defined but never used.","line":110,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":43,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is defined but never used.","line":111,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":112,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'operator' is defined but never used.","line":112,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":112,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":54,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filters' is defined but never used.","line":113,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":114,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'operator' is defined but never used.","line":114,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used.","line":114,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":57,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'column' is defined but never used.","line":115,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":23,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":115,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is defined but never used.","line":116,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'from' is defined but never used.","line":117,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'to' is defined but never used.","line":117,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'signal' is defined but never used.","line":118,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onfulfilled' is defined but never used.","line":123,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":123,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onrejected' is defined but never used.","line":124,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":124,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/supabase/server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/supabase/simple-client.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_table' is defined but never used.","line":29,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Simplified Supabase Client for Development\n * Bypasses complex module resolution issues\n */\n\n// Mock implementation for development\nexport const createSimpleClient = () => {\n  if (process.env.NODE_ENV === 'development') {\n    return {\n      auth: {\n        getUser: () => Promise.resolve({ \n          data: { \n            user: { \n              id: 'dev-user-123', \n              email: 'dev@example.com' \n            } \n          },\n          error: null \n        }),\n        signInWithPassword: () => Promise.resolve({ data: {}, error: null }),\n        signUp: () => Promise.resolve({ data: {}, error: null }),\n        signOut: () => Promise.resolve({ error: null }),\n        onAuthStateChange: (callback: (event: string, session: unknown) => void) => {\n          // Mock auth state change\n          setTimeout(() => callback('SIGNED_IN', { user: { id: 'dev-user-123' } }), 100);\n          return { data: { subscription: { unsubscribe: () => {} } } };\n        }\n      },\n      from: (_table: string) => ({\n        select: () => ({\n          eq: () => ({\n            order: () => ({\n              limit: () => Promise.resolve({ data: [], error: null })\n            })\n          })\n        }),\n        insert: () => Promise.resolve({ data: {}, error: null }),\n        update: () => Promise.resolve({ data: {}, error: null }),\n        delete: () => Promise.resolve({ data: {}, error: null })\n      })\n    };\n  }\n  \n  // In production, use real Supabase (lazy loaded)\n  return import('@supabase/supabase-js').then(({ createClient }) => \n    createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n    )\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/supabase/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/data-sanitizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":69,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Data sanitization utilities to prevent JSON serialization issues\n */\n\nimport type { StringKeyObject } from '@/types/core';\n\nexport function sanitizeForJson(obj: unknown): unknown {\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  // Handle primitive types\n  if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n    return obj;\n  }\n\n  // Handle dates\n  if (obj instanceof Date) {\n    return obj.toISOString();\n  }\n\n  // Handle arrays\n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeForJson(item));\n  }\n\n  // Handle objects\n  if (typeof obj === 'object') {\n    // Check for circular references or problematic objects\n    try {\n      JSON.stringify(obj);\n    } catch (error) {\n      console.warn('Object cannot be serialized, returning null:', error);\n      return null;\n    }\n\n    const sanitized: StringKeyObject = {};\n    for (const [key, value] of Object.entries(obj)) {\n      // Skip functions and undefined values\n      if (typeof value === 'function' || value === undefined) {\n        continue;\n      }\n\n      // Recursively sanitize nested objects\n      sanitized[key] = sanitizeForJson(value);\n    }\n    return sanitized;\n  }\n\n  // For any other type, try to convert to string safely\n  try {\n    const str = String(obj);\n    // Don't return \"[object Object]\" strings\n    if (str === '[object Object]') {\n      return null;\n    }\n    return str;\n  } catch (error) {\n    console.warn('Cannot convert to string, returning null:', error);\n    return null;\n  }\n}\n\nexport function isSerializable(obj: unknown): boolean {\n  try {\n    const sanitized = sanitizeForJson(obj);\n    JSON.stringify(sanitized);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function safeStringify(obj: unknown): string {\n  try {\n    const sanitized = sanitizeForJson(obj);\n    return JSON.stringify(sanitized);\n  } catch (error) {\n    console.warn('Failed to stringify object, returning empty object:', error);\n    return '{}';\n  }\n}\n\nexport function safeParse<T>(str: string, defaultValue: T): T {\n  try {\n    if (typeof str !== 'string') {\n      return defaultValue;\n    }\n\n    // Check for the problematic \"[object Object]\" pattern\n    if (str.includes('[object Object]') || str === '[object Object]') {\n      console.warn('Detected \"[object Object]\" pattern in JSON string');\n      return defaultValue;\n    }\n\n    const parsed = JSON.parse(str);\n    return parsed ?? defaultValue;\n  } catch (error) {\n    console.warn('Failed to parse JSON string:', error);\n    return defaultValue;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/export-utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weeks' is assigned a value but never used.","line":88,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Export Utilities for Analysis Results\n * Matches the original HTML export functionality\n */\n\nimport { DayCalculation, WeekCalculation, PaymentTotals } from '@/lib/services/payment-calculation-service';\n\nexport interface ExportData {\n  totals: PaymentTotals;\n  weeks: WeekCalculation[];\n  days: DayCalculation[];\n  metadata: {\n    exportDate: string;\n    analysisId: string;\n    period: string;\n    rulesVersion: string;\n  };\n}\n\n/**\n * Export analysis data as CSV format\n */\nexport function exportToCSV(data: ExportData): string {\n  const { days, totals, metadata } = data;\n  \n  let csv = '';\n  \n  // Header information\n  csv += `Payment Analysis Export\\n`;\n  csv += `Generated: ${new Date(metadata.exportDate).toLocaleDateString()}\\n`;\n  csv += `Period: ${metadata.period}\\n`;\n  csv += `Analysis ID: ${metadata.analysisId}\\n`;\n  csv += `\\n`;\n  \n  // Summary totals\n  csv += `SUMMARY TOTALS\\n`;\n  csv += `Working Days,${totals.workingDays}\\n`;\n  csv += `Total Consignments,${totals.totalConsignments}\\n`;\n  csv += `Expected Total,£${totals.expectedTotal.toFixed(2)}\\n`;\n  csv += `Paid Total,£${totals.paidTotal.toFixed(2)}\\n`;\n  csv += `Difference,£${totals.differenceTotal.toFixed(2)}\\n`;\n  csv += `Base Payment,£${totals.baseTotal.toFixed(2)}\\n`;\n  csv += `Total Bonuses,£${totals.bonusTotal.toFixed(2)}\\n`;\n  csv += `Pickup Total,£${totals.pickupTotal.toFixed(2)}\\n`;\n  csv += `\\n`;\n  \n  // Daily breakdown header\n  csv += `DAILY BREAKDOWN\\n`;\n  csv += `Date,Day,Consignments,Rate,Base Payment,Unloading Bonus,Attendance Bonus,Early Bonus,Pickup Count,Pickup Total,Expected Total,Paid Amount,Difference,Status\\n`;\n  \n  // Daily data\n  days.forEach(day => {\n    const status = day.difference >= 0 ? 'OK' : (Math.abs(day.difference) <= 5 ? 'Minor' : 'Review');\n    csv += `${day.date},${day.day},${day.consignments},£${day.rate.toFixed(2)},£${day.basePayment.toFixed(2)},£${day.unloadingBonus.toFixed(2)},£${day.attendanceBonus.toFixed(2)},£${day.earlyBonus.toFixed(2)},${day.pickupCount},£${day.pickupTotal.toFixed(2)},£${day.expectedTotal.toFixed(2)},£${day.paidAmount.toFixed(2)},£${day.difference.toFixed(2)},${status}\\n`;\n  });\n  \n  return csv;\n}\n\n/**\n * Export analysis data as JSON format\n */\nexport function exportToJSON(data: ExportData): string {\n  return JSON.stringify({\n    metadata: data.metadata,\n    summary: data.totals,\n    weeklyBreakdown: data.weeks.map(week => ({\n      weekStart: week.weekStart.toISOString(),\n      totalExpected: week.totalExpected,\n      totalActual: week.totalActual,\n      workingDays: week.workingDays,\n      totalConsignments: week.totalConsignments,\n      totalDifference: week.totalDifference,\n      days: week.days.length\n    })),\n    dailyBreakdown: data.days.map(day => ({\n      ...day,\n      formattedDate: new Date(day.date).toLocaleDateString(),\n      status: day.difference >= 0 ? 'OK' : (Math.abs(day.difference) <= 5 ? 'Minor' : 'Review')\n    }))\n  }, null, 2);\n}\n\n/**\n * Generate HTML report for printing\n */\nexport function exportToHTML(data: ExportData): string {\n  const { days, weeks, totals, metadata } = data;\n  \n  const formatCurrency = (amount: number) => `£${amount.toFixed(2)}`;\n  const formatDate = (date: string) => new Date(date).toLocaleDateString('en-GB');\n  \n  let html = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Payment Analysis Report - ${metadata.period}</title>\n    <style>\n        @page { size: A4; margin: 10mm; }\n        * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }\n        body { \n            margin: 0; padding: 0; background: white; font-size: 10pt; \n            line-height: 1.4; color: black; font-family: Georgia, 'Times New Roman', serif; \n        }\n        .header { \n            background: #f5f5f5; color: black; padding: 12pt; \n            border: 1pt solid #333; margin-bottom: 10pt; text-align: center; \n        }\n        .title { font-size: 16pt; font-weight: 900; margin-bottom: 6pt; }\n        .subtitle { font-size: 11pt; color: #444; margin-bottom: 10pt; }\n        .kpi-grid { \n            display: grid; grid-template-columns: repeat(5, 1fr); \n            gap: 6pt; margin-bottom: 10pt; \n        }\n        .kpi-card { \n            background: white; border: 1pt solid #666; padding: 6pt; \n            text-align: center; page-break-inside: avoid; \n        }\n        .kpi-label { \n            font-size: 6pt; color: #555; margin-bottom: 2pt; \n            text-transform: uppercase; font-weight: 700; \n            font-family: Verdana, Arial, sans-serif; \n        }\n        .kpi-value { \n            font-size: 12pt; color: black; font-weight: 900; \n            font-family: Georgia, serif; \n        }\n        table { \n            width: 100%; border-collapse: collapse; font-size: 8pt; \n            margin-bottom: 10pt; page-break-inside: auto; \n        }\n        th, td { border: 0.5pt solid #666; padding: 3pt; text-align: left; }\n        th { background: #f5f5f5; font-weight: bold; font-size: 7pt; }\n        .positive { color: green; font-weight: bold; }\n        .negative { color: red; font-weight: bold; }\n        .section-title { \n            font-size: 11pt; font-weight: 800; margin: 10pt 0 6pt 0; \n            padding-bottom: 3pt; border-bottom: 1pt solid #333; \n        }\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <div class=\"title\">Payment Analysis Report</div>\n        <div class=\"subtitle\">${metadata.period}</div>\n        <div style=\"font-size: 9pt;\">Generated: ${new Date(metadata.exportDate).toLocaleDateString()}</div>\n    </div>\n\n    <div class=\"section-title\">Key Performance Indicators</div>\n    <div class=\"kpi-grid\">\n        <div class=\"kpi-card\">\n            <div class=\"kpi-label\">Working Days</div>\n            <div class=\"kpi-value\">${totals.workingDays}</div>\n        </div>\n        <div class=\"kpi-card\">\n            <div class=\"kpi-label\">Consignments</div>\n            <div class=\"kpi-value\">${totals.totalConsignments}</div>\n        </div>\n        <div class=\"kpi-card\">\n            <div class=\"kpi-label\">Expected Total</div>\n            <div class=\"kpi-value\">${formatCurrency(totals.expectedTotal)}</div>\n        </div>\n        <div class=\"kpi-card\">\n            <div class=\"kpi-label\">Paid Total</div>\n            <div class=\"kpi-value\">${formatCurrency(totals.paidTotal)}</div>\n        </div>\n        <div class=\"kpi-card\">\n            <div class=\"kpi-label\">Difference</div>\n            <div class=\"kpi-value ${totals.differenceTotal >= 0 ? 'positive' : 'negative'}\">\n                ${totals.differenceTotal >= 0 ? '+' : ''}${formatCurrency(totals.differenceTotal)}\n            </div>\n        </div>\n    </div>\n\n    <div class=\"section-title\">Daily Breakdown</div>\n    <table>\n        <thead>\n            <tr>\n                <th>Date</th>\n                <th>Day</th>\n                <th>Consignments</th>\n                <th>Base Pay</th>\n                <th>Bonuses</th>\n                <th>Pickups</th>\n                <th>Expected</th>\n                <th>Paid</th>\n                <th>Difference</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n  `;\n  \n  days.forEach(day => {\n    const status = day.difference >= 0 ? 'OK' : (Math.abs(day.difference) <= 5 ? 'Minor' : 'Review');\n    const diffClass = day.difference >= 0 ? 'positive' : 'negative';\n    \n    html += `\n            <tr>\n                <td>${formatDate(day.date)}</td>\n                <td>${day.day}</td>\n                <td>${day.consignments || '-'}</td>\n                <td>${formatCurrency(day.basePayment)}</td>\n                <td>${formatCurrency(day.totalBonus)}</td>\n                <td>${day.pickupTotal > 0 ? `${formatCurrency(day.pickupTotal)} (${day.pickupCount})` : '-'}</td>\n                <td>${formatCurrency(day.expectedTotal)}</td>\n                <td>${formatCurrency(day.paidAmount)}</td>\n                <td class=\"${diffClass}\">${day.difference >= 0 ? '+' : ''}${formatCurrency(day.difference)}</td>\n                <td>${status}</td>\n            </tr>\n    `;\n  });\n  \n  html += `\n        </tbody>\n        <tfoot>\n            <tr style=\"font-weight: bold; background: #f9f9f9;\">\n                <td colspan=\"2\">TOTALS</td>\n                <td>${totals.totalConsignments}</td>\n                <td>${formatCurrency(totals.baseTotal)}</td>\n                <td>${formatCurrency(totals.bonusTotal)}</td>\n                <td>${formatCurrency(totals.pickupTotal)}</td>\n                <td>${formatCurrency(totals.expectedTotal)}</td>\n                <td>${formatCurrency(totals.paidTotal)}</td>\n                <td class=\"${totals.differenceTotal >= 0 ? 'positive' : 'negative'}\">\n                    ${totals.differenceTotal >= 0 ? '+' : ''}${formatCurrency(totals.differenceTotal)}\n                </td>\n                <td></td>\n            </tr>\n        </tfoot>\n    </table>\n\n    <div style=\"margin-top: 20pt; font-size: 8pt; color: #666; text-align: center;\">\n        Analysis ID: ${metadata.analysisId} | Rules Version: ${metadata.rulesVersion}\n    </div>\n</body>\n</html>\n  `;\n  \n  return html;\n}\n\n/**\n * Download file with given content and filename\n */\nexport function downloadFile(content: string, filename: string, mimeType: string = 'text/plain') {\n  const blob = new Blob([content], { type: mimeType });\n  const url = URL.createObjectURL(blob);\n  \n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  link.style.display = 'none';\n  \n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  \n  URL.revokeObjectURL(url);\n}\n\n/**\n * Trigger print dialog for HTML content\n */\nexport function printHTML(htmlContent: string) {\n  const printWindow = window.open('', '_blank');\n  if (printWindow) {\n    printWindow.document.write(htmlContent);\n    printWindow.document.close();\n    \n    // Wait for content to load then print\n    printWindow.onload = () => {\n      printWindow.print();\n      // Optionally close the window after printing\n      // printWindow.close();\n    };\n  }\n}\n\n/**\n * Generate filename for export based on analysis data\n */\nexport function generateExportFilename(\n  metadata: ExportData['metadata'], \n  format: 'csv' | 'json' | 'html'\n): string {\n  const date = new Date().toISOString().split('T')[0];\n  const period = metadata.period.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();\n  return `payment-analysis-${period}-${date}.${format}`;\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/payment-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/query-performance-monitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/safe-storage.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":13,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":55,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Safe storage utilities to prevent JSON parsing errors\n */\n\nexport class SafeStorage {\n  private static isStorageAvailable(type: 'localStorage' | 'sessionStorage'): boolean {\n    try {\n      const storage = window[type];\n      const x = '__storage_test__';\n      storage.setItem(x, x);\n      storage.removeItem(x);\n      return true;\n    } catch (_e) {\n      return false;\n    }\n  }\n\n  static setItem(key: string, value: unknown, useSession = false): boolean {\n    const storageType = useSession ? 'sessionStorage' : 'localStorage';\n    \n    if (!this.isStorageAvailable(storageType)) {\n      console.warn(`${storageType} is not available`);\n      return false;\n    }\n\n    try {\n      const serialized = JSON.stringify(value);\n      window[storageType].setItem(key, serialized);\n      return true;\n    } catch (error) {\n      console.warn(`Failed to set ${storageType} item \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  static getItem<T = unknown>(key: string, defaultValue: T | null = null, useSession = false): T | null {\n    const storageType = useSession ? 'sessionStorage' : 'localStorage';\n    \n    if (!this.isStorageAvailable(storageType)) {\n      return defaultValue;\n    }\n\n    try {\n      const item = window[storageType].getItem(key);\n      if (item === null) {\n        return defaultValue;\n      }\n      \n      return JSON.parse(item);\n    } catch (error) {\n      console.warn(`Failed to get ${storageType} item \"${key}\":`, error);\n      // Clear corrupted data\n      try {\n        window[storageType].removeItem(key);\n      } catch (_e) {\n        // Ignore cleanup errors\n      }\n      return defaultValue;\n    }\n  }\n\n  static removeItem(key: string, useSession = false): boolean {\n    const storageType = useSession ? 'sessionStorage' : 'localStorage';\n    \n    if (!this.isStorageAvailable(storageType)) {\n      return false;\n    }\n\n    try {\n      window[storageType].removeItem(key);\n      return true;\n    } catch (error) {\n      console.warn(`Failed to remove ${storageType} item \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  static clear(useSession = false): boolean {\n    const storageType = useSession ? 'sessionStorage' : 'localStorage';\n    \n    if (!this.isStorageAvailable(storageType)) {\n      return false;\n    }\n\n    try {\n      window[storageType].clear();\n      return true;\n    } catch (error) {\n      console.warn(`Failed to clear ${storageType}:`, error);\n      return false;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/storage-cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/storage-interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/supabase-cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/timezone-cache.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":85,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":85,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Timezone Cache Utility\n * \n * Addresses the major performance issue where `SELECT name FROM pg_timezone_names` \n * is consuming 34.8% of database query time (10.9 seconds across 64 calls).\n * \n * This utility implements client-side caching to reduce database calls.\n */\n\nimport { createClient } from '@/lib/supabase/client';\n\ninterface TimezoneCache {\n  data: string[];\n  lastFetch: number;\n  ttl: number; // Time to live in milliseconds\n}\n\nclass TimezoneManager {\n  private cache: TimezoneCache = {\n    data: [],\n    lastFetch: 0,\n    ttl: 24 * 60 * 60 * 1000, // 24 hours\n  };\n\n  private readonly STORAGE_KEY = 'timezone_cache_v1';\n  private readonly FALLBACK_TIMEZONES = [\n    'UTC',\n    'America/New_York',\n    'America/Los_Angeles',\n    'Europe/London',\n    'Europe/Paris',\n    'Asia/Tokyo',\n    'Australia/Sydney',\n  ];\n\n  constructor() {\n    // Load from localStorage if available\n    this.loadFromStorage();\n  }\n\n  /**\n   * Get timezones with caching\n   * Only hits the database if cache is expired or empty\n   */\n  async getTimezones(): Promise<string[]> {\n    const now = Date.now();\n    \n    // Return cached data if still valid\n    if (this.cache.data.length > 0 && (now - this.cache.lastFetch) < this.cache.ttl) {\n      return this.cache.data;\n    }\n\n    try {\n      // Try to fetch from materialized view first (created in migration)\n      const timezones = await this.fetchTimezonesFromDB();\n      \n      if (timezones.length > 0) {\n        this.updateCache(timezones);\n        return timezones;\n      }\n    } catch (error) {\n      console.warn('Failed to fetch timezones from database:', error);\n    }\n\n    // Fallback to cached data or default timezones\n    return this.cache.data.length > 0 ? this.cache.data : this.FALLBACK_TIMEZONES;\n  }\n\n  /**\n   * Fetch timezones from database (with fallback)\n   */\n  private async fetchTimezonesFromDB(): Promise<string[]> {\n    const supabase = createClient();\n\n    try {\n      // First try the materialized view (should be much faster)\n      const { data: cachedData, error: cachedError } = await supabase\n        .from('cached_timezone_names')\n        .select('name')\n        .order('name');\n\n      if (!cachedError && cachedData) {\n        return cachedData.map((row: { name: string }) => row.name);\n      }\n    } catch (_error) {\n      console.warn('Materialized view not available, falling back to direct query');\n    }\n\n    // Fallback to direct query (this is the slow one we're trying to avoid)\n    const { data, error } = await supabase\n      .rpc('get_timezone_names'); // We'll create this RPC function\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  }\n\n  /**\n   * Update cache and persist to storage\n   */\n  private updateCache(timezones: string[]): void {\n    this.cache = {\n      data: timezones,\n      lastFetch: Date.now(),\n      ttl: this.cache.ttl,\n    };\n\n    this.saveToStorage();\n  }\n\n  /**\n   * Load cache from localStorage\n   */\n  private loadFromStorage(): void {\n    if (typeof window === 'undefined') return;\n\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        this.cache = { ...this.cache, ...parsed };\n      }\n    } catch (error) {\n      console.warn('Failed to load timezone cache from storage:', error);\n    }\n  }\n\n  /**\n   * Save cache to localStorage\n   */\n  private saveToStorage(): void {\n    if (typeof window === 'undefined') return;\n\n    try {\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache));\n    } catch (error) {\n      console.warn('Failed to save timezone cache to storage:', error);\n    }\n  }\n\n  /**\n   * Force refresh the cache\n   */\n  async refresh(): Promise<string[]> {\n    this.cache.lastFetch = 0; // Force refresh\n    return this.getTimezones();\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache = {\n      data: [],\n      lastFetch: 0,\n      ttl: this.cache.ttl,\n    };\n\n    if (typeof window !== 'undefined') {\n      localStorage.removeItem(this.STORAGE_KEY);\n    }\n  }\n}\n\n// Export singleton instance\nexport const timezoneManager = new TimezoneManager();\n\n// Export utility functions\nexport const getTimezones = () => timezoneManager.getTimezones();\nexport const refreshTimezones = () => timezoneManager.refresh();\nexport const clearTimezoneCache = () => timezoneManager.clearCache();","usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/utils/week-report-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/workers/pdf-worker-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/lib/workers/pdf-worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/types/core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/src/types/modules.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/tailwind.config.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":41,"column":13,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":41,"endColumn":43,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/c/taly/Analyser/payment-analyzer-next/tests/test-env.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":3,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":3,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":4,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":4,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
